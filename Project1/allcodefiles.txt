/**
 * @file temp.h
 * @author Shreya Chakraborty
 * @brief header file for temperature task thread functionality
 * @version 0.1
 * @date 2019-03-16
 * 
 * @copyright Copyright (c) 2019
 * 
 */

#ifndef TEMP_H_
#define TEMP_H_


typedef enum 
{
    CELCIUS,
    KELVIN,
    FARENHEIT
}temp_unit;
/**
 * @brief to kill temp thread
 * Sets the kill thread in the task
 * 
 */
void kill_temp_thread(void);
/**
 * @brief call back for temperature task 
 * waits on a semaphore from the timer periodically
 * @param threadp 
 * @return void* 
 */
void *temp_task(void *threadp);
/**
 * @brief Get the Temp object.
 * Gets the temperature value from the temp register
 * 
 * @param unit 
 * @return float 
 */
float getTemperature(temp_unit unit);
/**
 * @brief Construct a new tmp102 settempthreshold object
 * sets thresholds for the temperature val
 * @param tlow_val 
 * @param thigh_val 
 */
int TMP102_setTempThreshold(float tlow_val,float thigh_val);
/**
 * @brief take threshold values from remote client
 * 
 * @param flow 
 * @param fhigh 
 * @return int 
 */
int RemoteThresholdValues(float flow,float fhigh);

#define GET_TEMP_KELVIN()       getTemperature(KELVIN)
#define GET_TEMP_CELCIUS()      getTemperature(CELCIUS)
#define GET_TEMP_FARENHEIT()    getTemperature(FARENHEIT)

#endif/**
 * @file mysignal.h
 * @author Shreya Chakraborty
 * @brief header file for signals
 * @version 0.1
 * @date 2019-03-16
 * 
 * @copyright Copyright (c) 2019
 * 
 */

#ifndef MYSIGNAL_H_
#define MYSIGNAL_H_
/**
 * @brief signal handler for CTRL-C 
 * 
 * @param signum 
 */
void signal_handler(int signum);

#endif/**
 * @file logger.h
 * @author Shreya Chakraborty
 * @brief Header file for logger task
 * @version 0.1
 * @date 2019-03-16
 * 
 * @copyright Copyright (c) 2019
 * 
 */

#ifndef LOGGER_H_
#define LOGGER_H_

#include <time.h>
#include <stdio.h>
#include <sys/time.h>
#include "includes.h"
#include "main.h"

//posix message queue attributes
#define LOG_QUEUE_NAME         "/logger_q"
#define QUEUE_PERMISSIONS   0666
#define MAX_MESSAGES        128
#define MAX_MSG_SIZE        256
#define CURRENT_MSG         0
#define FLAGS               0

#define LOG_STDOUT
static mqd_t mq_logger;

typedef enum{
    LOG_INVALID = -1,
    LOG_ERR = 0,          //Error conditions
    LOG_WARNING,          //Warning conditions
    LOG_INFO,             //Informational
    LOG_DEBUG,            //Debug-level messages
    LOG_MAX
}log_level_t;

const char * logLevel[LOG_MAX]; 
typedef struct{

    log_level_t level;
    char  msg[100];
    double timestamp;
    moduleId_t srcModuleID;

}log_struct_t;

struct loggerTask_param{

    char *filename;
    log_level_t loglevel;
};

/**
 * @brief macro function for printing on the console
 * 
 */
#define PRINTLOGCONSOLE(f_, ...)    do{\
             printf("[%lf] [PID:%d] [TID:%ld] Message:",getTimeMsec(),getpid(),syscall(SYS_gettid));\
             printf(f_, ##__VA_ARGS__);\
             printf("\n");\
             fflush(stdout);\
            }while(0)

#define PRINT(f_, ...)   printf(f_, ##__VA_ARGS__)

/**
 * @brief Macro functions for logger with levels
 * 
 */
#define LOG_INFO(modId, msg, ...)   LOG_ENQUEUE(LOG_INFO, modId, msg, ##__VA_ARGS__)
#define LOG_ERROR(modId, msg, ...)  LOG_ENQUEUE(LOG_ERR, modId, msg, ##__VA_ARGS__)
#define LOG_WARN(modId, msg, ...)   LOG_ENQUEUE(LOG_WARNING, modId, msg, ##__VA_ARGS__)
#define LOG_DEBUG(modId, msg, ...)  LOG_ENQUEUE(LOG_DEBUG, modId, msg, ##__VA_ARGS__)
/**
 * @brief to kill logger thread externally
 * 
 */
void kill_logger_thread(void);
/**
 * @brief to put messages in the logger queue
 * 
 * @param level log level 
 * @param modId the task
 * @param msg 
 * @param ... 
 * @return int 
 */
int LOG_ENQUEUE(log_level_t level ,moduleId_t modId, char *msg, ...);
/**
 * @brief queue initialisation
 * 
 * @return int 
 */
mqd_t logger_queue_init(void);

/**
 * @brief call back for logger task 
 * 
 * @param threadp 
 * @return void* 
 */
void *logger_task(void *threadp);
/**
 * @brief Get the Time Msec object
 * 
 * @return double 
 */
double getTimeMsec(void);
#endif/**
 * @file bist.h
 * @author Shreya Chakraborty
 * @brief header file for bist task thread functions
 * @version 0.1
 * @date 2019-03-16
 * 
 * @copyright Copyright (c) 2019
 * 
 */

#ifndef BIST_H_
#define BIST_H_

/**
 * @brief testing i2c init
 * 
 * @return int 
 */
int Test_I2C(void);
/**
 * @brief checking all thread status after creation from the global flag
 * 
 * @return int 
 */
int Test_AllThreads(void);
/**
 * @brief testing temperature register
 * 
 * @return int 
 */
int Test_TempSensor(void);
/**
 * @brief testing logger enqueue
 * 
 * @return int 
 */
int Test_loggerQ(void);
/**
 * @brief testing if light sensor is connected
 * 
 */
int Test_LightSensor(void);
/**
 * @brief call back function for bist task from main task
 * 
 * @param threadp 
 * @return void* 
 */
void *bist_task(void *threadp);
/**
 * @brief checks BIST_allOk flag to see if the bist was successful
 * 
 * @return int 
 */
int CheckBistResult(void);

/**
 * @brief posts semaphores to rest of the threads
 * 
 */
void PostBistOkResult(void);

#endif/**
 * @file heartbeat.h
 * @author Shreya Chakraborty
 * @brief header file for heartbeat functionality
 * @version 0.1
 * @date 2019-03-31
 * 
 * @copyright Copyright (c) 2019
 * 
 */
#ifndef HEARTBEAT_H_
#define HEARTBEAT_H_
#include "main.h"
/**
 * @brief Set the heartbeatFlag bit corresponding to each
 *  module that sets the heartbeat to the static volatile 
 * flag called g_heartbeat_taskFlags
 * 
 * @param moduleId 
 */
void set_heartbeatFlag(moduleId_t moduleId);
/**
 * @brief the heartbeat timer call back function
 * checks the global static heartbeat flag to
 * see if all the threads are alive 
 * 
 * @param sigval 
 * @return void
 */
void heatbeat_timer_callback(union sigval no);
/**
 * @brief starts the timer for heartbeat and calls
 * the callback function above
 * 
 */
void startHearbeatCheck(void);
/**
 * @brief sets the thread exit flags in each task modules
 * for clean exit
 * 
 */
void SystemExit(void);
#endif/**
 * @file mytimer.h
 * @author Shreya Chakraborty
 * @brief header file for timer functions
 * @version 0.1
 * @date 2019-03-31
 * 
 * @copyright Copyright (c) 2019
 * 
 */
#ifndef TIMER_H_
#define TIMER_H_

#include "includes.h"

/**
 * @brief initialise timer with call back functions
 * 
 * @param timerID 
 * @param callback 
 * @return int 
 */
int maketimer(timer_t *timerID, void (*callback)(union sigval));
/**
 * @brief starts timer for sensor threads
 * 
 * @param timerID 
 * @param sec 
 * @param nsec 
 * @return int 
 */
int startTimer(timer_t timerID,int sec,int nsec);
/**
 * @brief starts timer for heartbeat functions
 * 
 * @param timerID 
 * @param sec 
 * @param nsec 
 * @return int 
 */
int startTimerHB(timer_t timerID,int sec,int nsec);

/**
 * @brief stops the timer
 * 
 * @param timer_id 
 * @return int 
 */
int stopTimer(timer_t timer_id);

#endif
/**
 * @file socket.h
 * @author Shreya Chakraborty
 * @brief header for socket functionality
 * @version 0.1
 * @date 2019-03-16
 * 
 * @copyright Copyright (c) 2019
 * 
 */
#ifndef SOCKET_H_
#define SOCKET_H_
/**
 * @brief to kill socket thread
 * 
 */
void kill_socket_thread(void);
/**
 * @brief Call back function for socket from main thread
 * 
 * @param threadp 
 * @return void* 
 */
void *socket_task(void *threadp);

#endif/**
 * @file light.h
 * @author Shreya Chakraborty
 * @brief header file for the light Sensor task functionality
 * @version 0.1
 * @date 2019-03-16
 * 
 * @copyright Copyright (c) 2019
 * 
 */

#ifndef LIGHT_H_
#define LIGHT_H_
/* mraa header */
#include "mraa/gpio.h"
/**
 * @brief sets the threshold values for the light sensor
 * 
 * @param l_low 
 * @param l_high 
 * @return int 
 */
int APDS9301_setLightThreshold(uint16_t l_low,uint16_t l_high);
/**
 * @brief gets the streshold values from the remote client 
 * and changes the default values 
 * 
 * @param llow 
 * @param lhigh 
 * @return int 
 */
int RemoteThresholdValueslight(uint16_t llow,uint16_t lhigh);
/**
 * @brief checks the INT pin on the APDS9301 sensor
 * 
 * @param lightSensorIntPin 
 * @return int 
 */
int APDS9301_checkINTPIN(mraa_gpio_context lightSensorIntPin);
/**
 * @brief pin setup using gpio mraa library
 * 
 */
mraa_gpio_context APDS9301_IntPinSetup(int mraaPinNumber);
/**
 * @brief to kill light thread
 * sets the stop thread flag
 * 
 */
void kill_light_thread(void);
/**
 * @brief Call back for light task from main thread
 * 
 * @param threadp 
 * @return void* 
 */
void *light_task(void *threadp);
/**
 * @brief Get the Light object
 * 
 * @return float 
 */
float getLight(void);


#define GETLUX()        getLight()
#endif/**
 * @file main.h
 * @author shreya
 * @brief includes for main
 * @version 0.1
 * @date 2019-03-16
 * 
 * @copyright Copyright (c) 2019
 * 
 */
#ifndef MAIN_H_
#define MAIN_H_

extern int thread_flag[5];

typedef enum {
    BIST_TASK = 0,
    LOGGER_TASK,
    TEMP_TASK,
    LIGHT_TASK,
    SOCKET_TASK,
    MAIN_TASK,
    MAX_TASKS = MAIN_TASK, /*maximum no of tasks*/
}moduleId_t;

typedef struct{
    moduleId_t srcModuleID;
    char msg[100];
    int status;
}main_struct_t;


const char * moduleIdName[MAX_TASKS+1];


#endif/**
 * @file includes.h
 * @author your name (you@domain.com)
 * @brief 
 * @version 0.1
 * @date 2019-03-16
 * 
 * @copyright Copyright (c) 2019
 * 
 */

#ifndef INCLUDES_H_
#define INCLUDES_H_

#include <stdio.h>
#include <stdint.h>
#include <stddef.h>
#include <semaphore.h>
#include <pthread.h>
#include <mqueue.h>
#include <stdlib.h>
#include <unistd.h> 
#include <stdio.h> 
#include <sys/socket.h> 
#include <sys/select.h> 
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <string.h> 
#include <time.h>
#include <sys/time.h>
#include <signal.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <dirent.h>
#include <memory.h>
#include <errno.h>
#include <signal.h>
#include <openssl/md5.h>
#include <time.h>
#include <fcntl.h>           /* For O_* constants */
#include <stdarg.h>
#include <stddef.h>
#include <setjmp.h>
#include <sys/syscall.h>
#include <stdbool.h>
#include <math.h>

static volatile sig_atomic_t done = 0;
sem_t temp_sem;
sem_t light_sem;
sem_t socket_thread_sem;
sem_t light_thread_sem;
sem_t logger_thread_sem;
sem_t temp_thread_sem;


#define PORT 8888



#endif/**
 * @file lightSensor.h
 * @author Shreya Chakraborty
 * @brief header file for APDS9301 register functions
 * @version 0.1
 * @date 2019-03-22
 * @reference : https://github.com/sparkfun/APDS-9301_Breakout/blob/master/Libraries/Arduino/src/Sparkfun_APDS9301_Library.h
 * @copyright Copyright (c) 2019
 * 
 */
#ifndef LIGHTSENSOR_H_
#define LIGHTSENSOR_H_

#define APDS9301_SLAVE_ADDRESS      (0x39)
#define APDS9301_CONTROL_REG        (0x80)
#define APDS9301_TIMING_REG         (0x81)
#define APDS9301_THRESHLOWLOW_REG   (0x82)
#define APDS9301_THRESHLOWHI_REG    (0x83)
#define APDS9301_THRESHHILOW_REG    (0x84)
#define APDS9301_THRESHHIHI_REG     (0x85)
#define APDS9301_INTERRUPT_REG      (0x86)
#define APDS9301_ID_REG             (0x8A)
#define APDS9301_CH0_DATALOW_REG    (0x8C)
#define APDS9301_CH0_DATAHIGH_REG   (0x8D)
#define APDS9301_CH1_DATALOW_REG    (0x8E)
#define APDS9301_CH1_DATAHIGH_REG   (0x8F)

#define APDS9301_COMMAND_WORD_RW    (0x20)
#define APDS9301_COMMAND_INT_CLEAR  (0x40)

#define APDS9301_CONTROL_POWER_DOWN  (0x00)
#define APDS9301_CONTROL_POWER_UP    (0x03)
#define APDS9301_INTERRUPT_CTRL_ENABLE_DISABLE        (0x10)   
#define APDS9301_TIMING_GAIN        (0x10)
#define APDS9301_TIMING_INTEGRATION_TIME_BIT0 (0x01)
#define APDS9301_TIMING_INTEGRATION_TIME_BIT1 (0x02)


typedef enum{
    LOW,
    HIGH
}gain_mode_t;

typedef enum{
    MODE_ZERO,
    MODE_ONE,
    MODE_TWO,
    MODE_THREE,
}integ_time_t;

typedef enum{
    ENABLE,
    DISABLE
}interrupt_mode_t;
/**
 * @brief get ADC channel0 data
 * 
 * @param data 
 * @return int 
 */
int APDS9301_getCh0(uint16_t *data);
/**
 * @brief get ADC channel1 data
 * 
 * @param data 
 * @return int 
 */
int APDS9301_getCh1(uint16_t *data);
/**
 * @brief clears pending inteerupt
 * 
 * @return int 
 */
int APDS9301_intClear(void);
/**
 * @brief checks interrupt
 * 
 * @param data 
 * @return int 
 */
int APDS9301_CheckInt(uint8_t *data);
/**
 * @brief combine channel0 and 1 data to get lux
 * 
 * @param lux 
 * @return int 
 */
int APDS9301_getlight(float *lux);
/**
 * @brief read light id register
 * 
 * @param data 
 * @return int 
 */
int APDS9301_readIDreg(uint8_t *data);

/**
 * @brief powerup the light sensor 
 * 
 * @return int 
 */
int APDS9301_powerup();
/**
 * @brief write to command register
 * 
 * @param data 
 * @return int 
 */
int APDS9301_writeCMDreg(uint8_t data); // also write command register
/**
 * @brief read control register
 * 
 * @param data 
 * @return int 
 */
int APDS9301_readCTRLreg(uint8_t *data);
/**
 * @brief set gain in timing register
 * 
 * @param gain 
 * @return int 
 */
int APDS9301_setTiming_gain(gain_mode_t gain); //default value is low
/**
 * @brief set integration time in timing register
 * 
 * @param integTime 
 * @return int 
 */
int APDS9301_setTiming_integ(integ_time_t integTime);//mode 2 is default
/**
 * @brief set interrupt enable disable
 * 
 * @param option 
 * @return int 
 */
int APDS9301_interruptCTRLreg(interrupt_mode_t option); //default is disabled
/**
 * @brief write threshhold low low register
 * 
 * @param th_lowlow 
 * @return int 
 */
int APDS9301_writeTHRESH_lowlow(uint16_t th_lowlow);
/**
 * @brief read threshold low low register
 * 
 * @param th_lowlow 
 * @return int 
 */
int APDS9301_readTHRESH_lowlow(uint8_t *th_lowlow);
/**
 * @brief write threshold high low register
 * 
 * @param th_hilow 
 * @return int 
 */
int APDS9301_writeTHRESH_highlow(uint16_t th_hilow);
/**
 * @brief read threshold high low register
 * 
 * @param th_hilow 
 * @return int 
 */
int APDS9301_readTHRESH_highlow(uint8_t *th_hilow);
/**
 * @brief high high thres register
 * 
 * @param th_hihi 
 * @return int 
 */
int APDS9301_readTHRESH_highhigh(uint8_t *th_hihi);
/**
 * @brief low high threshold register
 * 
 * @param th_lowhi 
 * @return int 
 */
int APDS9301_readTHRESH_lowhigh(uint8_t *th_lowhi);
/**
 * @brief set all register values default
 * 
 * @return int 
 */
int APDS9301_setAllDefault();


#endif/**
 * @file myI2C.h
 * @author Shreya Chakraborty
 * @brief header for I2C drivers
 * @version 0.1
 * @date 2019-03-22
 * @Reference https://github.com/intel-iot-devkit/mraa/blob/master/examples/c/i2c_hmc5883l.c
 * @copyright Copyright (c) 2019
 * 
 */
#ifndef MYI2C_H_
#define MYI2C_H_
#include "mraa/i2c.h"
#define I2C_BUS  2

typedef struct
{
mraa_result_t status;
mraa_i2c_context i2c_context; 

}i2c_struct_t;

i2c_struct_t i2c_handler;
/**
 * @brief Initialise i2c context, passing in the i2c bus to use. 
 * 
 * @param i2c_handler 
 * @return int 
 */
int I2C_init(i2c_struct_t *i2c_handler);
/**
 * @brief close i2c context
 * 
 * @param i2c_handler 
 * @return int 
 */
int I2C_close(i2c_struct_t *i2c_handler);
/**
 * @brief set slave address for i2c read and write
 * 
 * @param i2c_handler 
 * @param slave_addr 
 * @return int 
 */
int I2C_set_slave(i2c_struct_t *i2c_handler,uint8_t slave_addr);
/**
 * @brief write 1 byte to the given slave address
 * 
 * @param i2c_handler 
 * @param slave_addr 
 * @param data 
 * @return int 
 */
int I2C_write_byte(i2c_struct_t *i2c_handler,uint8_t slave_addr,uint8_t data);

/**
 * @brief write 1 byte data 
 * 
 * @param i2c_handler 
 * @param slave_addr 
 * @param command_reg 
 * @param data 
 * @return int 
 */
int I2C_write_byte_data(i2c_struct_t *i2c_handler,uint8_t slave_addr,uint8_t command_reg,uint8_t data);

/**
 * @brief read 1 byte from the slave from the particular register
 * 
 * @param i2c_handler 
 * @param slave_addr 
 * @param command_reg 
 * @param data 
 * @return int 
 */
int I2C_read_byte(i2c_struct_t *i2c_handler,uint8_t slave_addr,uint8_t command_reg, uint8_t *data);
/**
 * @brief read multiple bytes from the command register of the slave into data
 * 
 * @param i2c_handler 
 * @param slave_addr 
 * @param command_reg 
 * @param data 
 * @param length 
 * @return int 
 */
int I2C_read_bytes(i2c_struct_t *i2c_handler,uint8_t slave_addr,uint8_t command_reg, uint8_t *data, size_t length);
/**
 * @brief write 2 bytes MSB first then lsb into the command register of the slave addr
 * 
 * @param i2c_handler 
 * @param slave_addr 
 * @param command_reg 
 * @param data 
 * @return int 
 */
int I2C_write_word(i2c_struct_t *i2c_handler,uint8_t slave_addr,uint8_t command_reg,uint16_t data);
#endif#ifndef I2C_H_
#define I2C_H_
#include <stdint.h>
/**
 * @brief 
 * 
 * @return int 
 */
int i2c_init(void);
/**
 * @brief 
 * 
 */
void i2c_close(void);
/**
 * @brief i2c write to register of slave device 
 * 
 * @param slave_addr 
 * @param reg 
 * @param data 
 * @return int 
 */
int i2c_write(uint8_t slave_addr, uint8_t reg, uint8_t data);
/**
 * @brief i2c read from register of slave device 
 * 
 * @param slave_addr 
 * @param reg 
 * @param result 
 * @return int 
 */
int i2c_read(uint8_t slave_addr, uint8_t reg, uint8_t *result);
#endif/**
 * @file tempSensor.h
 * @author your name (you@domain.com)
 * @brief 
 * @version 0.1
 * @date 2019-03-22
 * @reference https://github.com/torvalds/linux/blob/master/drivers/hwmon/tmp102.c
 * @copyright Copyright (c) 2019
 * 
 */
#ifndef TEMPSENSOR_H
#define TEMPSENSOR_H


/* Register address */
#define TMP102_SLAVE_ADDRESS            (0x48)
#define TMP102_TEMP_REG                 (0x00)
#define TMP102_CONFIG_REG               (0x01)
#define TMP102_TLOW_REG                 (0x02)
#define TMP102_THIGH_REG                (0x03)  
//config register is a 16 bit register with the following bit position byte1 msb followed by byte 2
#define		TMP102_CONF_SD		(1)  
#define		TMP102_CONF_TM		(1<<1)
#define		TMP102_CONF_POL		(1<<2)
#define		TMP102_CONF_F0		(1<<3)
#define		TMP102_CONF_F1		(1<<4)
#define		TMP102_CONF_R0		(1<<5)
#define		TMP102_CONF_R1		(1<<6)
#define		TMP102_CONF_OS		(1<<7)
#define		TMP102_CONF_EM		(1<<12)
#define		TMP102_CONF_AL		(1<<13)
#define		TMP102_CONF_CR0		(1<<14)
#define		TMP102_CONF_CR1		(1<<15)

#define TMP102_CONFREG_MASK	(TMP102_CONF_SD | TMP102_CONF_TM | \
				 TMP102_CONF_POL | TMP102_CONF_F0 | \
				 TMP102_CONF_F1 | TMP102_CONF_OS | \
				 TMP102_CONF_EM | TMP102_CONF_AL | \
				 TMP102_CONF_CR0 | TMP102_CONF_CR1)

#define TMP102_CONFIG_CLEAR	(TMP102_CONF_SD | TMP102_CONF_OS | \
				 TMP102_CONF_CR0)
#define TMP102_CONFIG_SET	(TMP102_CONF_TM | TMP102_CONF_EM | \
				 TMP102_CONF_CR1)
#define FAULTBITSMASK			0x1800

typedef enum{
	R0R1_SET,
	R1_SET,
	R0_SET,
	R0R1_CLEAR
}sensor_resolution_t;

typedef enum{
	ONE_FAULT,
	TWO_FAULTS,
	FOUR_FAULTS,
	SIX_FAULTS
}fault_setting_t;

typedef enum{
	NORMAL,
	EXTENDED
}EM_mode_t;

typedef enum{
	POWERSAVING,
	DEFAULT
}shutdown_mode_t;

typedef enum{
	ONE_FOURTH_HZ,
	ONE_HZ,
	FOUR_HZ,
	EIGHT_HZ
}conversion_rate_t;
/**
 * @brief get temperature raw value
 * 
 * @param temp_val 
 * @return int 
 */
int TMP102_getTemperature(float *temp_val);
/**
 * @brief read tlow reg
 * 
 * @param tlow_val 
 * @return int 
 */
int TMP102_getTlow(float *tlow_val);
/**
 * @brief read thigh register
 * 
 * @param thigh_val 
 * @return int 
 */
int TMP102_getThigh(float *thigh_val);
/**
 * @brief write to thigh reg
 * 
 * @param thigh_val 
 * @return int 
 */
int TMP102_setThigh(float thigh_val); // default value is 80 deg celcius 
/**
 * @brief write to tlow reg
 * 
 * @param tlow_val 
 * @return int 
 */
int TMP102_setTlow(float tlow_val); //default value is 75 deg celcius
/**
 * @brief read any reg
 * 
 * @param reg 
 * @param data 
 * @return int 
 */
int TMP102_readReg(uint8_t reg, uint8_t *data);
/**
 * @brief write to ptr reg 
 * 
 * @param reg 
 * @return int 
 */
int TMP102_writePTRreg(uint8_t reg);
/**
 * @brief set shutdown mode
 * 
 * @param option 
 * @return int 
 */
int TMP102_setShutdownMode(shutdown_mode_t option); //SD bit in config register default is DEFAULT
//sensor resolution R1/R0, option - 0 is default 12 bits
/**
 * @brief set resolution 
 * 
 * @param option 
 * @return int 
 */
int TMP102_setResolution(sensor_resolution_t option); //default R0R1 set
/**
 * @brief read fault bits
 * 
 * @param data 
 * @return int 
 */
int TMP102_getFaultbits(uint16_t *data); // default mode is F1 AND F0 clear
/**
 * @brief set fault bits
 * 
 * @param option 
 * @return int 
 */
int TMP102_setFaultbits(fault_setting_t option); //default is 1 fault
/**
 * @brief set EM mode
 * 
 * @param option 
 * @return int 
 */
int TMP102_setEM(EM_mode_t option);// default is normal mode
/**
 * @brief set conversion rate
 * 
 * @param option 
 * @return int 
 */
int TMP102_setCR(conversion_rate_t option);
/**
 * @brief read AL bit
 * 
 * @param bit 
 * @return int 
 */
int TMP102_readAL( uint8_t *bit);
/**
 * @brief set all registers to default value
 * 
 * @return int 
 */
int TMP102_setAllDefault();
#endif
/**
 * @file bbgled.h
 * @author Shreya Chakraborty
 * @brief header file for external led functionality connected to BBG
 * @version 0.1
 * @date 2019-03-31
 * 
 * @copyright Copyright (c) 2019
 * 
 */
#ifndef BBGLED_H_
#define BBGLED_H_
#include <stdbool.h>
/**
 * @brief turn on off red led
 * 
 * @param option 
 * @return int 
 */
int redLed_OnOff(bool option);
/**
 * @brief turn on off green led 
 * 
 * @param option 
 * @return int 
 */
int greenLed_OnOff(bool option);

#define REDLEDON()      redLed_OnOff(1)
#define REDLEDOFF()     redLed_OnOff(0)
#define GREENLEDON()    greenLed_OnOff(1) 
#define GREENLEDOFF()   greenLed_OnOff(0)

#endif/*
 * Copyright 2008 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef CMOCKA_H_
#define CMOCKA_H_

#ifdef _WIN32
# ifdef _MSC_VER

# ifndef inline
#define inline __inline
# endif /* inline */

#  if _MSC_VER < 1500
#   ifdef __cplusplus
extern "C" {
#   endif   /* __cplusplus */
int __stdcall IsDebuggerPresent();
#   ifdef __cplusplus
} /* extern "C" */
#   endif   /* __cplusplus */
#  endif  /* _MSC_VER < 1500 */
# endif /* _MSC_VER */
#endif  /* _WIN32 */

/**
 * @defgroup cmocka The CMocka API
 *
 * These headers or their equivalents should be included prior to including
 * this header file.
 * @code
 * #include <stdarg.h>
 * #include <stddef.h>
 * #include <setjmp.h>
 * @endcode
 *
 * This allows test applications to use custom definitions of C standard
 * library functions and types.
 *
 * @{
 */

/* For those who are used to __func__ from gcc. */
#ifndef __func__
#define __func__ __FUNCTION__
#endif

/* If __WORDSIZE is not set, try to figure it out and default to 32 bit. */
#ifndef __WORDSIZE
# if defined(__x86_64__) && !defined(__ILP32__)
#  define __WORDSIZE 64
# else
#  define __WORDSIZE 32
# endif
#endif

#ifdef DOXYGEN
/**
 * Largest integral type.  This type should be large enough to hold any
 * pointer or integer supported by the compiler.
 */
typedef uintmax_t LargestIntegralType;
#else /* DOXGEN */
#ifndef LargestIntegralType
# if __WORDSIZE == 64
#  define LargestIntegralType unsigned long int
# else
#  define LargestIntegralType unsigned long long int
# endif
#endif /* LargestIntegralType */
#endif /* DOXYGEN */

/* Printf format used to display LargestIntegralType. */
#ifndef LargestIntegralTypePrintfFormat
# ifdef _WIN32
#  define LargestIntegralTypePrintfFormat "0x%I64x"
# else
#  if __WORDSIZE == 64
#   define LargestIntegralTypePrintfFormat "%#lx"
#  else
#   define LargestIntegralTypePrintfFormat "%#llx"
#  endif
# endif /* _WIN32 */
#endif /* LargestIntegralTypePrintfFormat */

/* Perform an unsigned cast to LargestIntegralType. */
#define cast_to_largest_integral_type(value) \
    ((LargestIntegralType)(value))

/* Smallest integral type capable of holding a pointer. */
#if !defined(_UINTPTR_T) && !defined(_UINTPTR_T_DEFINED)
# if defined(_WIN32)
    /* WIN32 is an ILP32 platform */
    typedef unsigned int uintptr_t;
# elif defined(_WIN64)
    typedef unsigned long int uintptr_t
# else /* _WIN32 */

/* ILP32 and LP64 platforms */
#  ifdef __WORDSIZE /* glibc */
#   if __WORDSIZE == 64
      typedef unsigned long int uintptr_t;
#   else
      typedef unsigned int uintptr_t;
#   endif /* __WORDSIZE == 64 */
#  else /* __WORDSIZE */
#   if defined(_LP64) || defined(_I32LPx)
      typedef unsigned long int uintptr_t;
#   else
      typedef unsigned int uintptr_t;
#   endif
#  endif /* __WORDSIZE */
# endif /* _WIN32 */

# define _UINTPTR_T
# define _UINTPTR_T_DEFINED
#endif /* !defined(_UINTPTR_T) || !defined(_UINTPTR_T_DEFINED) */

/* Perform an unsigned cast to uintptr_t. */
#define cast_to_pointer_integral_type(value) \
    ((uintptr_t)((size_t)(value)))

/* Perform a cast of a pointer to LargestIntegralType */
#define cast_ptr_to_largest_integral_type(value) \
cast_to_largest_integral_type(cast_to_pointer_integral_type(value))

/* GCC have printf type attribute check.  */
#ifdef __GNUC__
#define CMOCKA_PRINTF_ATTRIBUTE(a,b) \
    __attribute__ ((__format__ (__printf__, a, b)))
#else
#define CMOCKA_PRINTF_ATTRIBUTE(a,b)
#endif /* __GNUC__ */

#if defined(__GNUC__)
#define CMOCKA_DEPRECATED __attribute__ ((deprecated))
#elif defined(_MSC_VER)
#define CMOCKA_DEPRECATED __declspec(deprecated)
#else
#define CMOCKA_DEPRECATED
#endif

/**
 * @defgroup cmocka_mock Mock Objects
 * @ingroup cmocka
 *
 * Mock objects mock objects are simulated objects that mimic the behavior of
 * real objects. Instead of calling the real objects, the tested object calls a
 * mock object that merely asserts that the correct methods were called, with
 * the expected parameters, in the correct order.
 *
 * <ul>
 * <li><strong>will_return(function, value)</strong> - The will_return() macro
 * pushes a value onto a stack of mock values. This macro is intended to be
 * used by the unit test itself, while programming the behaviour of the mocked
 * object.</li>
 *
 * <li><strong>mock()</strong> - the mock macro pops a value from a stack of
 * test values. The user of the mock() macro is the mocked object that uses it
 * to learn how it should behave.</li>
 * </ul>
 *
 * Because the will_return() and mock() are intended to be used in pairs, the
 * cmocka library would fail the test if there are more values pushed onto the
 * stack using will_return() than consumed with mock() and vice-versa.
 *
 * The following unit test stub illustrates how would a unit test instruct the
 * mock object to return a particular value:
 *
 * @code
 * will_return(chef_cook, "hotdog");
 * will_return(chef_cook, 0);
 * @endcode
 *
 * Now the mock object can check if the parameter it received is the parameter
 * which is expected by the test driver. This can be done the following way:
 *
 * @code
 * int chef_cook(const char *order, char **dish_out)
 * {
 *     check_expected(order);
 * }
 * @endcode
 *
 * For a complete example please at a look
 * <a href="http://git.cryptomilk.org/projects/cmocka.git/tree/example/chef_wrap/waiter_test_wrap.c">here</a>.
 *
 * @{
 */

#ifdef DOXYGEN
/**
 * @brief Retrieve a return value of the current function.
 *
 * @return The value which was stored to return by this function.
 *
 * @see will_return()
 */
LargestIntegralType mock(void);
#else
#define mock() _mock(__func__, __FILE__, __LINE__)
#endif

#ifdef DOXYGEN
/**
 * @brief Retrieve a typed return value of the current function.
 *
 * The value would be casted to type internally to avoid having the
 * caller to do the cast manually.
 *
 * @param[in]  #type  The expected type of the return value
 *
 * @return The value which was stored to return by this function.
 *
 * @code
 * int param;
 *
 * param = mock_type(int);
 * @endcode
 *
 * @see will_return()
 * @see mock()
 * @see mock_ptr_type()
 */
#type mock_type(#type);
#else
#define mock_type(type) ((type) mock())
#endif

#ifdef DOXYGEN
/**
 * @brief Retrieve a typed return value of the current function.
 *
 * The value would be casted to type internally to avoid having the
 * caller to do the cast manually but also casted to uintptr_t to make
 * sure the result has a valid size to be used as a pointer.
 *
 * @param[in]  #type  The expected type of the return value
 *
 * @return The value which was stored to return by this function.
 *
 * @code
 * char *param;
 *
 * param = mock_ptr_type(char *);
 * @endcode
 *
 * @see will_return()
 * @see mock()
 * @see mock_type()
 */
type mock_ptr_type(#type);
#else
#define mock_ptr_type(type) ((type) (uintptr_t) mock())
#endif


#ifdef DOXYGEN
/**
 * @brief Store a value to be returned by mock() later.
 *
 * @param[in]  #function  The function which should return the given value.
 *
 * @param[in]  value The value to be returned by mock().
 *
 * @code
 * int return_integer(void)
 * {
 *      return (int)mock();
 * }
 *
 * static void test_integer_return(void **state)
 * {
 *      will_return(return_integer, 42);
 *
 *      assert_int_equal(my_function_calling_return_integer(), 42);
 * }
 * @endcode
 *
 * @see mock()
 * @see will_return_count()
 */
void will_return(#function, LargestIntegralType value);
#else
#define will_return(function, value) \
    _will_return(#function, __FILE__, __LINE__, \
                 cast_to_largest_integral_type(value), 1)
#endif

#ifdef DOXYGEN
/**
 * @brief Store a value to be returned by mock() later.
 *
 * @param[in]  #function  The function which should return the given value.
 *
 * @param[in]  value The value to be returned by mock().
 *
 * @param[in]  count The parameter returns the number of times the value should
 *                   be returned by mock(). If count is set to -1 the value will
 *                   always be returned.
 *
 * @see mock()
 */
void will_return_count(#function, LargestIntegralType value, int count);
#else
#define will_return_count(function, value, count) \
    _will_return(#function, __FILE__, __LINE__, \
                 cast_to_largest_integral_type(value), count)
#endif

#ifdef DOXYGEN
/**
 * @brief Store a value that will be always returned by mock().
 *
 * @param[in]  #function  The function which should return the given value.
 *
 * @param[in]  #value The value to be returned by mock().
 *
 * This is equivalent to:
 * @code
 * will_return_count(function, value, -1);
 * @endcode
 *
 * @see will_return_count()
 * @see mock()
 */
void will_return_always(#function, LargestIntegralType value);
#else
#define will_return_always(function, value) \
    will_return_count(function, (value), -1)
#endif

/** @} */

/**
 * @defgroup cmocka_param Checking Parameters
 * @ingroup cmocka
 *
 * Functionality to store expected values for mock function parameters.
 *
 * In addition to storing the return values of mock functions, cmocka provides
 * functionality to store expected values for mock function parameters using
 * the expect_*() functions provided. A mock function parameter can then be
 * validated using the check_expected() macro.
 *
 * Successive calls to expect_*() macros for a parameter queues values to check
 * the specified parameter. check_expected() checks a function parameter
 * against the next value queued using expect_*(), if the parameter check fails
 * a test failure is signalled. In addition if check_expected() is called and
 * no more parameter values are queued a test failure occurs.
 *
 * The following test stub illustrates how to do this. First is the the function
 * we call in the test driver:
 *
 * @code
 * static void test_driver(void **state)
 * {
 *     expect_string(chef_cook, order, "hotdog");
 * }
 * @endcode
 *
 * Now the chef_cook function can check if the parameter we got passed is the
 * parameter which is expected by the test driver. This can be done the
 * following way:
 *
 * @code
 * int chef_cook(const char *order, char **dish_out)
 * {
 *     check_expected(order);
 * }
 * @endcode
 *
 * For a complete example please at a look at
 * <a href="http://git.cryptomilk.org/projects/cmocka.git/tree/example/chef_wrap/waiter_test_wrap.c">here</a>
 *
 * @{
 */

/*
 * Add a custom parameter checking function.  If the event parameter is NULL
 * the event structure is allocated internally by this function.  If event
 * parameter is provided it must be allocated on the heap and doesn't need to
 * be deallocated by the caller.
 */
#ifdef DOXYGEN
/**
 * @brief Add a custom parameter checking function.
 *
 * If the event parameter is NULL the event structure is allocated internally
 * by this function. If the parameter is provided it must be allocated on the
 * heap and doesn't need to be deallocated by the caller.
 *
 * @param[in]  #function  The function to add a custom parameter checking
 *                        function for.
 *
 * @param[in]  #parameter The parameters passed to the function.
 *
 * @param[in]  #check_function  The check function to call.
 *
 * @param[in]  check_data       The data to pass to the check function.
 */
void expect_check(#function, #parameter, #check_function, const void *check_data);
#else
#define expect_check(function, parameter, check_function, check_data) \
    _expect_check(#function, #parameter, __FILE__, __LINE__, check_function, \
                  cast_to_largest_integral_type(check_data), NULL, 1)
#endif

#ifdef DOXYGEN
/**
 * @brief Add an event to check if the parameter value is part of the provided
 *        array.
 *
 * The event is triggered by calling check_expected() in the mocked function.
 *
 * @param[in]  #function  The function to add the check for.
 *
 * @param[in]  #parameter The name of the parameter passed to the function.
 *
 * @param[in]  value_array[] The array to check for the value.
 *
 * @see check_expected().
 */
void expect_in_set(#function, #parameter, LargestIntegralType value_array[]);
#else
#define expect_in_set(function, parameter, value_array) \
    expect_in_set_count(function, parameter, value_array, 1)
#endif

#ifdef DOXYGEN
/**
 * @brief Add an event to check if the parameter value is part of the provided
 *        array.
 *
 * The event is triggered by calling check_expected() in the mocked function.
 *
 * @param[in]  #function  The function to add the check for.
 *
 * @param[in]  #parameter The name of the parameter passed to the function.
 *
 * @param[in]  value_array[] The array to check for the value.
 *
 * @param[in]  count  The count parameter returns the number of times the value
 *                    should be returned by check_expected(). If count is set
 *                    to -1 the value will always be returned.
 *
 * @see check_expected().
 */
void expect_in_set_count(#function, #parameter, LargestIntegralType value_array[], size_t count);
#else
#define expect_in_set_count(function, parameter, value_array, count) \
    _expect_in_set(#function, #parameter, __FILE__, __LINE__, value_array, \
                   sizeof(value_array) / sizeof((value_array)[0]), count)
#endif

#ifdef DOXYGEN
/**
 * @brief Add an event to check if the parameter value is not part of the
 *        provided array.
 *
 * The event is triggered by calling check_expected() in the mocked function.
 *
 * @param[in]  #function  The function to add the check for.
 *
 * @param[in]  #parameter The name of the parameter passed to the function.
 *
 * @param[in]  value_array[] The array to check for the value.
 *
 * @see check_expected().
 */
void expect_not_in_set(#function, #parameter, LargestIntegralType value_array[]);
#else
#define expect_not_in_set(function, parameter, value_array) \
    expect_not_in_set_count(function, parameter, value_array, 1)
#endif

#ifdef DOXYGEN
/**
 * @brief Add an event to check if the parameter value is not part of the
 *        provided array.
 *
 * The event is triggered by calling check_expected() in the mocked function.
 *
 * @param[in]  #function  The function to add the check for.
 *
 * @param[in]  #parameter The name of the parameter passed to the function.
 *
 * @param[in]  value_array[] The array to check for the value.
 *
 * @param[in]  count  The count parameter returns the number of times the value
 *                    should be returned by check_expected(). If count is set
 *                    to -1 the value will always be returned.
 *
 * @see check_expected().
 */
void expect_not_in_set_count(#function, #parameter, LargestIntegralType value_array[], size_t count);
#else
#define expect_not_in_set_count(function, parameter, value_array, count) \
    _expect_not_in_set( \
        #function, #parameter, __FILE__, __LINE__, value_array, \
        sizeof(value_array) / sizeof((value_array)[0]), count)
#endif


#ifdef DOXYGEN
/**
 * @brief Add an event to check a parameter is inside a numerical range.
 * The check would succeed if minimum <= value <= maximum.
 *
 * The event is triggered by calling check_expected() in the mocked function.
 *
 * @param[in]  #function  The function to add the check for.
 *
 * @param[in]  #parameter The name of the parameter passed to the function.
 *
 * @param[in]  minimum  The lower boundary of the interval to check against.
 *
 * @param[in]  maximum  The upper boundary of the interval to check against.
 *
 * @see check_expected().
 */
void expect_in_range(#function, #parameter, LargestIntegralType minimum, LargestIntegralType maximum);
#else
#define expect_in_range(function, parameter, minimum, maximum) \
    expect_in_range_count(function, parameter, minimum, maximum, 1)
#endif

#ifdef DOXYGEN
/**
 * @brief Add an event to repeatedly check a parameter is inside a
 * numerical range. The check would succeed if minimum <= value <= maximum.
 *
 * The event is triggered by calling check_expected() in the mocked function.
 *
 * @param[in]  #function  The function to add the check for.
 *
 * @param[in]  #parameter The name of the parameter passed to the function.
 *
 * @param[in]  minimum  The lower boundary of the interval to check against.
 *
 * @param[in]  maximum  The upper boundary of the interval to check against.
 *
 * @param[in]  count  The count parameter returns the number of times the value
 *                    should be returned by check_expected(). If count is set
 *                    to -1 the value will always be returned.
 *
 * @see check_expected().
 */
void expect_in_range_count(#function, #parameter, LargestIntegralType minimum, LargestIntegralType maximum, size_t count);
#else
#define expect_in_range_count(function, parameter, minimum, maximum, count) \
    _expect_in_range(#function, #parameter, __FILE__, __LINE__, minimum, \
                     maximum, count)
#endif

#ifdef DOXYGEN
/**
 * @brief Add an event to check a parameter is outside a numerical range.
 * The check would succeed if minimum > value > maximum.
 *
 * The event is triggered by calling check_expected() in the mocked function.
 *
 * @param[in]  #function  The function to add the check for.
 *
 * @param[in]  #parameter The name of the parameter passed to the function.
 *
 * @param[in]  minimum  The lower boundary of the interval to check against.
 *
 * @param[in]  maximum  The upper boundary of the interval to check against.
 *
 * @see check_expected().
 */
void expect_not_in_range(#function, #parameter, LargestIntegralType minimum, LargestIntegralType maximum);
#else
#define expect_not_in_range(function, parameter, minimum, maximum) \
    expect_not_in_range_count(function, parameter, minimum, maximum, 1)
#endif

#ifdef DOXYGEN
/**
 * @brief Add an event to repeatedly check a parameter is outside a
 * numerical range. The check would succeed if minimum > value > maximum.
 *
 * The event is triggered by calling check_expected() in the mocked function.
 *
 * @param[in]  #function  The function to add the check for.
 *
 * @param[in]  #parameter The name of the parameter passed to the function.
 *
 * @param[in]  minimum  The lower boundary of the interval to check against.
 *
 * @param[in]  maximum  The upper boundary of the interval to check against.
 *
 * @param[in]  count  The count parameter returns the number of times the value
 *                    should be returned by check_expected(). If count is set
 *                    to -1 the value will always be returned.
 *
 * @see check_expected().
 */
void expect_not_in_range_count(#function, #parameter, LargestIntegralType minimum, LargestIntegralType maximum, size_t count);
#else
#define expect_not_in_range_count(function, parameter, minimum, maximum, \
                                  count) \
    _expect_not_in_range(#function, #parameter, __FILE__, __LINE__, \
                         minimum, maximum, count)
#endif

#ifdef DOXYGEN
/**
 * @brief Add an event to check if a parameter is the given value.
 *
 * The event is triggered by calling check_expected() in the mocked function.
 *
 * @param[in]  #function  The function to add the check for.
 *
 * @param[in]  #parameter The name of the parameter passed to the function.
 *
 * @param[in]  value  The value to check.
 *
 * @see check_expected().
 */
void expect_value(#function, #parameter, LargestIntegralType value);
#else
#define expect_value(function, parameter, value) \
    expect_value_count(function, parameter, value, 1)
#endif

#ifdef DOXYGEN
/**
 * @brief Add an event to repeatedly check if a parameter is the given value.
 *
 * The event is triggered by calling check_expected() in the mocked function.
 *
 * @param[in]  #function  The function to add the check for.
 *
 * @param[in]  #parameter The name of the parameter passed to the function.
 *
 * @param[in]  value  The value to check.
 *
 * @param[in]  count  The count parameter returns the number of times the value
 *                    should be returned by check_expected(). If count is set
 *                    to -1 the value will always be returned.
 *
 * @see check_expected().
 */
void expect_value_count(#function, #parameter, LargestIntegralType value, size_t count);
#else
#define expect_value_count(function, parameter, value, count) \
    _expect_value(#function, #parameter, __FILE__, __LINE__, \
                  cast_to_largest_integral_type(value), count)
#endif

#ifdef DOXYGEN
/**
 * @brief Add an event to check if a parameter isn't the given value.
 *
 * The event is triggered by calling check_expected() in the mocked function.
 *
 * @param[in]  #function  The function to add the check for.
 *
 * @param[in]  #parameter The name of the parameter passed to the function.
 *
 * @param[in]  value  The value to check.
 *
 * @see check_expected().
 */
void expect_not_value(#function, #parameter, LargestIntegralType value);
#else
#define expect_not_value(function, parameter, value) \
    expect_not_value_count(function, parameter, value, 1)
#endif

#ifdef DOXYGEN
/**
 * @brief Add an event to repeatedly check if a parameter isn't the given value.
 *
 * The event is triggered by calling check_expected() in the mocked function.
 *
 * @param[in]  #function  The function to add the check for.
 *
 * @param[in]  #parameter The name of the parameter passed to the function.
 *
 * @param[in]  value  The value to check.
 *
 * @param[in]  count  The count parameter returns the number of times the value
 *                    should be returned by check_expected(). If count is set
 *                    to -1 the value will always be returned.
 *
 * @see check_expected().
 */
void expect_not_value_count(#function, #parameter, LargestIntegralType value, size_t count);
#else
#define expect_not_value_count(function, parameter, value, count) \
    _expect_not_value(#function, #parameter, __FILE__, __LINE__, \
                      cast_to_largest_integral_type(value), count)
#endif

#ifdef DOXYGEN
/**
 * @brief Add an event to check if the parameter value is equal to the
 *        provided string.
 *
 * The event is triggered by calling check_expected() in the mocked function.
 *
 * @param[in]  #function  The function to add the check for.
 *
 * @param[in]  #parameter The name of the parameter passed to the function.
 *
 * @param[in]  string   The string value to compare.
 *
 * @see check_expected().
 */
void expect_string(#function, #parameter, const char *string);
#else
#define expect_string(function, parameter, string) \
    expect_string_count(function, parameter, string, 1)
#endif

#ifdef DOXYGEN
/**
 * @brief Add an event to check if the parameter value is equal to the
 *        provided string.
 *
 * The event is triggered by calling check_expected() in the mocked function.
 *
 * @param[in]  #function  The function to add the check for.
 *
 * @param[in]  #parameter The name of the parameter passed to the function.
 *
 * @param[in]  string   The string value to compare.
 *
 * @param[in]  count  The count parameter returns the number of times the value
 *                    should be returned by check_expected(). If count is set
 *                    to -1 the value will always be returned.
 *
 * @see check_expected().
 */
void expect_string_count(#function, #parameter, const char *string, size_t count);
#else
#define expect_string_count(function, parameter, string, count) \
    _expect_string(#function, #parameter, __FILE__, __LINE__, \
                   (const char*)(string), count)
#endif

#ifdef DOXYGEN
/**
 * @brief Add an event to check if the parameter value isn't equal to the
 *        provided string.
 *
 * The event is triggered by calling check_expected() in the mocked function.
 *
 * @param[in]  #function  The function to add the check for.
 *
 * @param[in]  #parameter The name of the parameter passed to the function.
 *
 * @param[in]  string   The string value to compare.
 *
 * @see check_expected().
 */
void expect_not_string(#function, #parameter, const char *string);
#else
#define expect_not_string(function, parameter, string) \
    expect_not_string_count(function, parameter, string, 1)
#endif

#ifdef DOXYGEN
/**
 * @brief Add an event to check if the parameter value isn't equal to the
 *        provided string.
 *
 * The event is triggered by calling check_expected() in the mocked function.
 *
 * @param[in]  #function  The function to add the check for.
 *
 * @param[in]  #parameter The name of the parameter passed to the function.
 *
 * @param[in]  string   The string value to compare.
 *
 * @param[in]  count  The count parameter returns the number of times the value
 *                    should be returned by check_expected(). If count is set
 *                    to -1 the value will always be returned.
 *
 * @see check_expected().
 */
void expect_not_string_count(#function, #parameter, const char *string, size_t count);
#else
#define expect_not_string_count(function, parameter, string, count) \
    _expect_not_string(#function, #parameter, __FILE__, __LINE__, \
                       (const char*)(string), count)
#endif

#ifdef DOXYGEN
/**
 * @brief Add an event to check if the parameter does match an area of memory.
 *
 * The event is triggered by calling check_expected() in the mocked function.
 *
 * @param[in]  #function  The function to add the check for.
 *
 * @param[in]  #parameter The name of the parameter passed to the function.
 *
 * @param[in]  memory  The memory to compare.
 *
 * @param[in]  size  The size of the memory to compare.
 *
 * @see check_expected().
 */
void expect_memory(#function, #parameter, void *memory, size_t size);
#else
#define expect_memory(function, parameter, memory, size) \
    expect_memory_count(function, parameter, memory, size, 1)
#endif

#ifdef DOXYGEN
/**
 * @brief Add an event to repeatedly check if the parameter does match an area
 *        of memory.
 *
 * The event is triggered by calling check_expected() in the mocked function.
 *
 * @param[in]  #function  The function to add the check for.
 *
 * @param[in]  #parameter The name of the parameter passed to the function.
 *
 * @param[in]  memory  The memory to compare.
 *
 * @param[in]  size  The size of the memory to compare.
 *
 * @param[in]  count  The count parameter returns the number of times the value
 *                    should be returned by check_expected(). If count is set
 *                    to -1 the value will always be returned.
 *
 * @see check_expected().
 */
void expect_memory_count(#function, #parameter, void *memory, size_t size, size_t count);
#else
#define expect_memory_count(function, parameter, memory, size, count) \
    _expect_memory(#function, #parameter, __FILE__, __LINE__, \
                   (const void*)(memory), size, count)
#endif

#ifdef DOXYGEN
/**
 * @brief Add an event to check if the parameter doesn't match an area of
 *        memory.
 *
 * The event is triggered by calling check_expected() in the mocked function.
 *
 * @param[in]  #function  The function to add the check for.
 *
 * @param[in]  #parameter The name of the parameter passed to the function.
 *
 * @param[in]  memory  The memory to compare.
 *
 * @param[in]  size  The size of the memory to compare.
 *
 * @see check_expected().
 */
void expect_not_memory(#function, #parameter, void *memory, size_t size);
#else
#define expect_not_memory(function, parameter, memory, size) \
    expect_not_memory_count(function, parameter, memory, size, 1)
#endif

#ifdef DOXYGEN
/**
 * @brief Add an event to repeatedly check if the parameter doesn't match an
 *        area of memory.
 *
 * The event is triggered by calling check_expected() in the mocked function.
 *
 * @param[in]  #function  The function to add the check for.
 *
 * @param[in]  #parameter The name of the parameter passed to the function.
 *
 * @param[in]  memory  The memory to compare.
 *
 * @param[in]  size  The size of the memory to compare.
 *
 * @param[in]  count  The count parameter returns the number of times the value
 *                    should be returned by check_expected(). If count is set
 *                    to -1 the value will always be returned.
 *
 * @see check_expected().
 */
void expect_not_memory_count(#function, #parameter, void *memory, size_t size, size_t count);
#else
#define expect_not_memory_count(function, parameter, memory, size, count) \
    _expect_not_memory(#function, #parameter, __FILE__, __LINE__, \
                       (const void*)(memory), size, count)
#endif


#ifdef DOXYGEN
/**
 * @brief Add an event to check if a parameter (of any value) has been passed.
 *
 * The event is triggered by calling check_expected() in the mocked function.
 *
 * @param[in]  #function  The function to add the check for.
 *
 * @param[in]  #parameter The name of the parameter passed to the function.
 *
 * @see check_expected().
 */
void expect_any(#function, #parameter);
#else
#define expect_any(function, parameter) \
    expect_any_count(function, parameter, 1)
#endif

#ifdef DOXYGEN
/**
 * @brief Add an event to repeatedly check if a parameter (of any value) has
 *        been passed.
 *
 * The event is triggered by calling check_expected() in the mocked function.
 *
 * @param[in]  #function  The function to add the check for.
 *
 * @param[in]  #parameter The name of the parameter passed to the function.
 *
 * @param[in]  count  The count parameter returns the number of times the value
 *                    should be returned by check_expected(). If count is set
 *                    to -1 the value will always be returned.
 *
 * @see check_expected().
 */
void expect_any_count(#function, #parameter, size_t count);
#else
#define expect_any_count(function, parameter, count) \
    _expect_any(#function, #parameter, __FILE__, __LINE__, count)
#endif

#ifdef DOXYGEN
/**
 * @brief Determine whether a function parameter is correct.
 *
 * This ensures the next value queued by one of the expect_*() macros matches
 * the specified variable.
 *
 * This function needs to be called in the mock object.
 *
 * @param[in]  #parameter  The parameter to check.
 */
void check_expected(#parameter);
#else
#define check_expected(parameter) \
    _check_expected(__func__, #parameter, __FILE__, __LINE__, \
                    cast_to_largest_integral_type(parameter))
#endif

#ifdef DOXYGEN
/**
 * @brief Determine whether a function parameter is correct.
 *
 * This ensures the next value queued by one of the expect_*() macros matches
 * the specified variable.
 *
 * This function needs to be called in the mock object.
 *
 * @param[in]  #parameter  The pointer to check.
 */
void check_expected_ptr(#parameter);
#else
#define check_expected_ptr(parameter) \
    _check_expected(__func__, #parameter, __FILE__, __LINE__, \
                    cast_ptr_to_largest_integral_type(parameter))
#endif

/** @} */

/**
 * @defgroup cmocka_asserts Assert Macros
 * @ingroup cmocka
 *
 * This is a set of useful assert macros like the standard C libary's
 * assert(3) macro.
 *
 * On an assertion failure a cmocka assert macro will write the failure to the
 * standard error stream and signal a test failure. Due to limitations of the C
 * language the general C standard library assert() and cmocka's assert_true()
 * and assert_false() macros can only display the expression that caused the
 * assert failure. cmocka's type specific assert macros, assert_{type}_equal()
 * and assert_{type}_not_equal(), display the data that caused the assertion
 * failure which increases data visibility aiding debugging of failing test
 * cases.
 *
 * @{
 */

#ifdef DOXYGEN
/**
 * @brief Assert that the given expression is true.
 *
 * The function prints an error message to standard error and terminates the
 * test by calling fail() if expression is false (i.e., compares equal to
 * zero).
 *
 * @param[in]  expression  The expression to evaluate.
 *
 * @see assert_int_equal()
 * @see assert_string_equal()
 */
void assert_true(scalar expression);
#else
#define assert_true(c) _assert_true(cast_to_largest_integral_type(c), #c, \
                                    __FILE__, __LINE__)
#endif

#ifdef DOXYGEN
/**
 * @brief Assert that the given expression is false.
 *
 * The function prints an error message to standard error and terminates the
 * test by calling fail() if expression is true.
 *
 * @param[in]  expression  The expression to evaluate.
 *
 * @see assert_int_equal()
 * @see assert_string_equal()
 */
void assert_false(scalar expression);
#else
#define assert_false(c) _assert_true(!(cast_to_largest_integral_type(c)), #c, \
                                     __FILE__, __LINE__)
#endif

#ifdef DOXYGEN
/**
 * @brief Assert that the return_code is greater than or equal to 0.
 *
 * The function prints an error message to standard error and terminates the
 * test by calling fail() if the return code is smaller than 0. If the function
 * you check sets an errno if it fails you can pass it to the function and
 * it will be printed as part of the error message.
 *
 * @param[in]  rc       The return code to evaluate.
 *
 * @param[in]  error    Pass errno here or 0.
 */
void assert_return_code(int rc, int error);
#else
#define assert_return_code(rc, error) \
    _assert_return_code(cast_to_largest_integral_type(rc), \
                        sizeof(rc), \
                        cast_to_largest_integral_type(error), \
                        #rc, __FILE__, __LINE__)
#endif

#ifdef DOXYGEN
/**
 * @brief Assert that the given pointer is non-NULL.
 *
 * The function prints an error message to standard error and terminates the
 * test by calling fail() if the pointer is non-NULL.
 *
 * @param[in]  pointer  The pointer to evaluate.
 *
 * @see assert_null()
 */
void assert_non_null(void *pointer);
#else
#define assert_non_null(c) _assert_true(cast_ptr_to_largest_integral_type(c), #c, \
                                        __FILE__, __LINE__)
#endif

#ifdef DOXYGEN
/**
 * @brief Assert that the given pointer is NULL.
 *
 * The function prints an error message to standard error and terminates the
 * test by calling fail() if the pointer is non-NULL.
 *
 * @param[in]  pointer  The pointer to evaluate.
 *
 * @see assert_non_null()
 */
void assert_null(void *pointer);
#else
#define assert_null(c) _assert_true(!(cast_ptr_to_largest_integral_type(c)), #c, \
__FILE__, __LINE__)
#endif

#ifdef DOXYGEN
/**
 * @brief Assert that the two given integers are equal.
 *
 * The function prints an error message to standard error and terminates the
 * test by calling fail() if the integers are not equal.
 *
 * @param[in]  a  The first integer to compare.
 *
 * @param[in]  b  The integer to compare against the first one.
 */
void assert_int_equal(int a, int b);
#else
#define assert_int_equal(a, b) \
    _assert_int_equal(cast_to_largest_integral_type(a), \
                      cast_to_largest_integral_type(b), \
                      __FILE__, __LINE__)
#endif

#ifdef DOXYGEN
/**
 * @brief Assert that the two given integers are not equal.
 *
 * The function prints an error message to standard error and terminates the
 * test by calling fail() if the integers are equal.
 *
 * @param[in]  a  The first integer to compare.
 *
 * @param[in]  b  The integer to compare against the first one.
 *
 * @see assert_int_equal()
 */
void assert_int_not_equal(int a, int b);
#else
#define assert_int_not_equal(a, b) \
    _assert_int_not_equal(cast_to_largest_integral_type(a), \
                          cast_to_largest_integral_type(b), \
                          __FILE__, __LINE__)
#endif

#ifdef DOXYGEN
/**
 * @brief Assert that the two given strings are equal.
 *
 * The function prints an error message to standard error and terminates the
 * test by calling fail() if the strings are not equal.
 *
 * @param[in]  a  The string to check.
 *
 * @param[in]  b  The other string to compare.
 */
void assert_string_equal(const char *a, const char *b);
#else
#define assert_string_equal(a, b) \
    _assert_string_equal((const char*)(a), (const char*)(b), __FILE__, \
                         __LINE__)
#endif

#ifdef DOXYGEN
/**
 * @brief Assert that the two given strings are not equal.
 *
 * The function prints an error message to standard error and terminates the
 * test by calling fail() if the strings are equal.
 *
 * @param[in]  a  The string to check.
 *
 * @param[in]  b  The other string to compare.
 */
void assert_string_not_equal(const char *a, const char *b);
#else
#define assert_string_not_equal(a, b) \
    _assert_string_not_equal((const char*)(a), (const char*)(b), __FILE__, \
                             __LINE__)
#endif

#ifdef DOXYGEN
/**
 * @brief Assert that the two given areas of memory are equal, otherwise fail.
 *
 * The function prints an error message to standard error and terminates the
 * test by calling fail() if the memory is not equal.
 *
 * @param[in]  a  The first memory area to compare
 *                (interpreted as unsigned char).
 *
 * @param[in]  b  The second memory area to compare
 *                (interpreted as unsigned char).
 *
 * @param[in]  size  The first n bytes of the memory areas to compare.
 */
void assert_memory_equal(const void *a, const void *b, size_t size);
#else
#define assert_memory_equal(a, b, size) \
    _assert_memory_equal((const void*)(a), (const void*)(b), size, __FILE__, \
                         __LINE__)
#endif

#ifdef DOXYGEN
/**
 * @brief Assert that the two given areas of memory are not equal.
 *
 * The function prints an error message to standard error and terminates the
 * test by calling fail() if the memory is equal.
 *
 * @param[in]  a  The first memory area to compare
 *                (interpreted as unsigned char).
 *
 * @param[in]  b  The second memory area to compare
 *                (interpreted as unsigned char).
 *
 * @param[in]  size  The first n bytes of the memory areas to compare.
 */
void assert_memory_not_equal(const void *a, const void *b, size_t size);
#else
#define assert_memory_not_equal(a, b, size) \
    _assert_memory_not_equal((const void*)(a), (const void*)(b), size, \
                             __FILE__, __LINE__)
#endif

#ifdef DOXYGEN
/**
 * @brief Assert that the specified value is not smaller than the minimum
 * and and not greater than the maximum.
 *
 * The function prints an error message to standard error and terminates the
 * test by calling fail() if value is not in range.
 *
 * @param[in]  value  The value to check.
 *
 * @param[in]  minimum  The minimum value allowed.
 *
 * @param[in]  maximum  The maximum value allowed.
 */
void assert_in_range(LargestIntegralType value, LargestIntegralType minimum, LargestIntegralType maximum);
#else
#define assert_in_range(value, minimum, maximum) \
    _assert_in_range( \
        cast_to_largest_integral_type(value), \
        cast_to_largest_integral_type(minimum), \
        cast_to_largest_integral_type(maximum), __FILE__, __LINE__)
#endif

#ifdef DOXYGEN
/**
 * @brief Assert that the specified value is smaller than the minimum or
 * greater than the maximum.
 *
 * The function prints an error message to standard error and terminates the
 * test by calling fail() if value is in range.
 *
 * @param[in]  value  The value to check.
 *
 * @param[in]  minimum  The minimum value to compare.
 *
 * @param[in]  maximum  The maximum value to compare.
 */
void assert_not_in_range(LargestIntegralType value, LargestIntegralType minimum, LargestIntegralType maximum);
#else
#define assert_not_in_range(value, minimum, maximum) \
    _assert_not_in_range( \
        cast_to_largest_integral_type(value), \
        cast_to_largest_integral_type(minimum), \
        cast_to_largest_integral_type(maximum), __FILE__, __LINE__)
#endif

#ifdef DOXYGEN
/**
 * @brief Assert that the specified value is within a set.
 *
 * The function prints an error message to standard error and terminates the
 * test by calling fail() if value is not within a set.
 *
 * @param[in]  value  The value to look up
 *
 * @param[in]  values[]  The array to check for the value.
 *
 * @param[in]  count  The size of the values array.
 */
void assert_in_set(LargestIntegralType value, LargestIntegralType values[], size_t count);
#else
#define assert_in_set(value, values, number_of_values) \
    _assert_in_set(value, values, number_of_values, __FILE__, __LINE__)
#endif

#ifdef DOXYGEN
/**
 * @brief Assert that the specified value is not within a set.
 *
 * The function prints an error message to standard error and terminates the
 * test by calling fail() if value is within a set.
 *
 * @param[in]  value  The value to look up
 *
 * @param[in]  values[]  The array to check for the value.
 *
 * @param[in]  count  The size of the values array.
 */
void assert_not_in_set(LargestIntegralType value, LargestIntegralType values[], size_t count);
#else
#define assert_not_in_set(value, values, number_of_values) \
    _assert_not_in_set(value, values, number_of_values, __FILE__, __LINE__)
#endif

/** @} */

/**
 * @defgroup cmocka_exec Running Tests
 * @ingroup cmocka
 *
 * This is the way tests are executed with CMocka.
 *
 * The following example illustrates this macro's use with the unit_test macro.
 *
 * @code
 * void Test0(void **state);
 * void Test1(void **state);
 *
 * int main(void)
 * {
 *     const struct CMUnitTest tests[] = {
 *         cmocka_unit_test(Test0),
 *         cmocka_unit_test(Test1),
 *     };
 *
 *     return cmocka_run_group_tests(tests, NULL, NULL);
 * }
 * @endcode
 *
 * @{
 */

#ifdef DOXYGEN
/**
 * @brief Forces the test to fail immediately and quit.
 */
void fail(void);
#else
#define fail() _fail(__FILE__, __LINE__)
#endif

#ifdef DOXYGEN
/**
 * @brief Forces the test to not be executed, but marked as skipped
 */
void skip(void);
#else
#define skip() _skip(__FILE__, __LINE__)
#endif

#ifdef DOXYGEN
/**
 * @brief Forces the test to fail immediately and quit, printing the reason.
 *
 * @code
 * fail_msg("This is some error message for test");
 * @endcode
 *
 * or
 *
 * @code
 * char *error_msg = "This is some error message for test";
 * fail_msg("%s", error_msg);
 * @endcode
 */
void fail_msg(const char *msg, ...);
#else
#define fail_msg(msg, ...) do { \
    print_error("ERROR: " msg "\n", ##__VA_ARGS__); \
    fail(); \
} while (0)
#endif

#ifdef DOXYGEN
/**
 * @brief Generic method to run a single test.
 *
 * @deprecated This function was deprecated in favor of cmocka_run_group_tests
 *
 * @param[in]  #function The function to test.
 *
 * @return 0 on success, 1 if an error occured.
 *
 * @code
 * // A test case that does nothing and succeeds.
 * void null_test_success(void **state) {
 * }
 *
 * int main(void) {
 *      return run_test(null_test_success);
 * }
 * @endcode
 */
int run_test(#function);
#else
#define run_test(f) _run_test(#f, f, NULL, UNIT_TEST_FUNCTION_TYPE_TEST, NULL)
#endif

static inline void _unit_test_dummy(void **state) {
    (void)state;
}

/** Initializes a UnitTest structure.
 *
 * @deprecated This function was deprecated in favor of cmocka_unit_test
 */
#define unit_test(f) { #f, f, UNIT_TEST_FUNCTION_TYPE_TEST }

#define _unit_test_setup(test, setup) \
    { #test "_" #setup, setup, UNIT_TEST_FUNCTION_TYPE_SETUP }

/** Initializes a UnitTest structure with a setup function.
 *
 * @deprecated This function was deprecated in favor of cmocka_unit_test_setup
 */
#define unit_test_setup(test, setup) \
    _unit_test_setup(test, setup), \
    unit_test(test), \
    _unit_test_teardown(test, _unit_test_dummy)

#define _unit_test_teardown(test, teardown) \
    { #test "_" #teardown, teardown, UNIT_TEST_FUNCTION_TYPE_TEARDOWN }

/** Initializes a UnitTest structure with a teardown function.
 *
 * @deprecated This function was deprecated in favor of cmocka_unit_test_teardown
 */
#define unit_test_teardown(test, teardown) \
    _unit_test_setup(test, _unit_test_dummy), \
    unit_test(test), \
    _unit_test_teardown(test, teardown)

/** Initializes a UnitTest structure for a group setup function.
 *
 * @deprecated This function was deprecated in favor of cmocka_run_group_tests
 */
#define group_test_setup(setup) \
    { "group_" #setup, setup, UNIT_TEST_FUNCTION_TYPE_GROUP_SETUP }

/** Initializes a UnitTest structure for a group teardown function.
 *
 * @deprecated This function was deprecated in favor of cmocka_run_group_tests
 */
#define group_test_teardown(teardown) \
    { "group_" #teardown, teardown, UNIT_TEST_FUNCTION_TYPE_GROUP_TEARDOWN }

/**
 * Initialize an array of UnitTest structures with a setup function for a test
 * and a teardown function.  Either setup or teardown can be NULL.
 *
 * @deprecated This function was deprecated in favor of
 * cmocka_unit_test_setup_teardown
 */
#define unit_test_setup_teardown(test, setup, teardown) \
    _unit_test_setup(test, setup), \
    unit_test(test), \
    _unit_test_teardown(test, teardown)


/** Initializes a CMUnitTest structure. */
#define cmocka_unit_test(f) { #f, f, NULL, NULL }

/** Initializes a CMUnitTest structure with a setup function. */
#define cmocka_unit_test_setup(f, setup) { #f, f, setup, NULL }

/** Initializes a CMUnitTest structure with a teardown function. */
#define cmocka_unit_test_teardown(f, teardown) { #f, f, NULL, teardown }

/**
 * Initialize an array of CMUnitTest structures with a setup function for a test
 * and a teardown function. Either setup or teardown can be NULL.
 */
#define cmocka_unit_test_setup_teardown(f, setup, teardown) { #f, f, setup, teardown }

#define run_tests(tests) _run_tests(tests, sizeof(tests) / sizeof(tests)[0])
#define run_group_tests(tests) _run_group_tests(tests, sizeof(tests) / sizeof(tests)[0])

#ifdef DOXYGEN
/**
 * @brief Run tests specified by an array of CMUnitTest structures.
 *
 * @param[in]  group_tests[]  The array of unit tests to execute.
 *
 * @param[in]  group_setup    The setup function which should be called before
 *                            all unit tests are executed.
 *
 * @param[in]  group_teardown The teardown function to be called after all
 *                            tests have finished.
 *
 * @return 0 on success, or the number of failed tests.
 *
 * @code
 * static int setup(void **state) {
 *      int *answer = malloc(sizeof(int));
 *      if (*answer == NULL) {
 *          return -1;
 *      }
 *      *answer = 42;
 *
 *      *state = answer;
 *
 *      return 0;
 * }
 *
 * static void teardown(void **state) {
 *      free(*state);
 *
 *      return 0;
 * }
 *
 * static void null_test_success(void **state) {
 *     (void) state;
 * }
 *
 * static void int_test_success(void **state) {
 *      int *answer = *state;
 *      assert_int_equal(*answer, 42);
 * }
 *
 * int main(void) {
 *     const struct CMUnitTest tests[] = {
 *         cmocka_unit_test(null_test_success),
 *         cmocka_unit_test_setup_teardown(int_test_success, setup, teardown),
 *     };
 *
 *     return cmocka_run_group_tests(tests, NULL, NULL);
 * }
 * @endcode
 *
 * @see cmocka_unit_test
 * @see cmocka_unit_test_setup
 * @see cmocka_unit_test_teardown
 * @see cmocka_unit_test_setup_teardown
 */
int cmocka_run_group_tests(const struct CMUnitTest group_tests[],
                           CMFixtureFunction group_setup,
                           CMFixtureFunction group_teardown);
#else
# define cmocka_run_group_tests(group_tests, group_setup, group_teardown) \
        _cmocka_run_group_tests(#group_tests, group_tests, sizeof(group_tests) / sizeof(group_tests)[0], group_setup, group_teardown)
#endif

#ifdef DOXYGEN
/**
 * @brief Run tests specified by an array of CMUnitTest structures and specify
 *        a name.
 *
 * @param[in]  group_name     The name of the group test.
 *
 * @param[in]  group_tests[]  The array of unit tests to execute.
 *
 * @param[in]  group_setup    The setup function which should be called before
 *                            all unit tests are executed.
 *
 * @param[in]  group_teardown The teardown function to be called after all
 *                            tests have finished.
 *
 * @return 0 on success, or the number of failed tests.
 *
 * @code
 * static int setup(void **state) {
 *      int *answer = malloc(sizeof(int));
 *      if (*answer == NULL) {
 *          return -1;
 *      }
 *      *answer = 42;
 *
 *      *state = answer;
 *
 *      return 0;
 * }
 *
 * static void teardown(void **state) {
 *      free(*state);
 *
 *      return 0;
 * }
 *
 * static void null_test_success(void **state) {
 *     (void) state;
 * }
 *
 * static void int_test_success(void **state) {
 *      int *answer = *state;
 *      assert_int_equal(*answer, 42);
 * }
 *
 * int main(void) {
 *     const struct CMUnitTest tests[] = {
 *         cmocka_unit_test(null_test_success),
 *         cmocka_unit_test_setup_teardown(int_test_success, setup, teardown),
 *     };
 *
 *     return cmocka_run_group_tests_name("success_test", tests, NULL, NULL);
 * }
 * @endcode
 *
 * @see cmocka_unit_test
 * @see cmocka_unit_test_setup
 * @see cmocka_unit_test_teardown
 * @see cmocka_unit_test_setup_teardown
 */
int cmocka_run_group_tests_name(const char *group_name,
                                const struct CMUnitTest group_tests[],
                                CMFixtureFunction group_setup,
                                CMFixtureFunction group_teardown);
#else
# define cmocka_run_group_tests_name(group_name, group_tests, group_setup, group_teardown) \
        _cmocka_run_group_tests(group_name, group_tests, sizeof(group_tests) / sizeof(group_tests)[0], group_setup, group_teardown)
#endif

/** @} */

/**
 * @defgroup cmocka_alloc Dynamic Memory Allocation
 * @ingroup cmocka
 *
 * Memory leaks, buffer overflows and underflows can be checked using cmocka.
 *
 * To test for memory leaks, buffer overflows and underflows a module being
 * tested by cmocka should replace calls to malloc(), calloc() and free() to
 * test_malloc(), test_calloc() and test_free() respectively. Each time a block
 * is deallocated using test_free() it is checked for corruption, if a corrupt
 * block is found a test failure is signalled. All blocks allocated using the
 * test_*() allocation functions are tracked by the cmocka library. When a test
 * completes if any allocated blocks (memory leaks) remain they are reported
 * and a test failure is signalled.
 *
 * For simplicity cmocka currently executes all tests in one process. Therefore
 * all test cases in a test application share a single address space which
 * means memory corruption from a single test case could potentially cause the
 * test application to exit prematurely.
 *
 * @{
 */

#ifdef DOXYGEN
/**
 * @brief Test function overriding malloc.
 *
 * @param[in]  size  The bytes which should be allocated.
 *
 * @return A pointer to the allocated memory or NULL on error.
 *
 * @code
 * #ifdef UNIT_TESTING
 * extern void* _test_malloc(const size_t size, const char* file, const int line);
 *
 * #define malloc(size) _test_malloc(size, __FILE__, __LINE__)
 * #endif
 *
 * void leak_memory() {
 *     int * const temporary = (int*)malloc(sizeof(int));
 *     *temporary = 0;
 * }
 * @endcode
 *
 * @see malloc(3)
 */
void *test_malloc(size_t size);
#else
#define test_malloc(size) _test_malloc(size, __FILE__, __LINE__)
#endif

#ifdef DOXYGEN
/**
 * @brief Test function overriding calloc.
 *
 * The memory is set to zero.
 *
 * @param[in]  nmemb  The number of elements for an array to be allocated.
 *
 * @param[in]  size   The size in bytes of each array element to allocate.
 *
 * @return A pointer to the allocated memory, NULL on error.
 *
 * @see calloc(3)
 */
void *test_calloc(size_t nmemb, size_t size);
#else
#define test_calloc(num, size) _test_calloc(num, size, __FILE__, __LINE__)
#endif

#ifdef DOXYGEN
/**
 * @brief Test function overriding realloc which detects buffer overruns
 *        and memoery leaks.
 *
 * @param[in]  ptr   The memory block which should be changed.
 *
 * @param[in]  size  The bytes which should be allocated.
 *
 * @return           The newly allocated memory block, NULL on error.
 */
void *test_realloc(void *ptr, size_t size);
#else
#define test_realloc(ptr, size) _test_realloc(ptr, size, __FILE__, __LINE__)
#endif

#ifdef DOXYGEN
/**
 * @brief Test function overriding free(3).
 *
 * @param[in]  ptr  The pointer to the memory space to free.
 *
 * @see free(3).
 */
void test_free(void *ptr);
#else
#define test_free(ptr) _test_free(ptr, __FILE__, __LINE__)
#endif

/* Redirect malloc, calloc and free to the unit test allocators. */
#ifdef UNIT_TESTING
#define malloc test_malloc
#define realloc test_realloc
#define calloc test_calloc
#define free test_free
#endif /* UNIT_TESTING */

/** @} */


/**
 * @defgroup cmocka_mock_assert Standard Assertions
 * @ingroup cmocka
 *
 * How to handle assert(3) of the standard C library.
 *
 * Runtime assert macros like the standard C library's assert() should be
 * redefined in modules being tested to use cmocka's mock_assert() function.
 * Normally mock_assert() signals a test failure. If a function is called using
 * the expect_assert_failure() macro, any calls to mock_assert() within the
 * function will result in the execution of the test. If no calls to
 * mock_assert() occur during the function called via expect_assert_failure() a
 * test failure is signalled.
 *
 * @{
 */

/**
 * @brief Function to replace assert(3) in tested code.
 *
 * In conjuction with check_assert() it's possible to determine whether an
 * assert condition has failed without stopping a test.
 *
 * @param[in]  result  The expression to assert.
 *
 * @param[in]  expression  The expression as string.
 *
 * @param[in]  file  The file mock_assert() is called.
 *
 * @param[in]  line  The line mock_assert() is called.
 *
 * @code
 * #ifdef UNIT_TESTING
 * extern void mock_assert(const int result, const char* const expression,
 *                         const char * const file, const int line);
 *
 * #undef assert
 * #define assert(expression) \
 *     mock_assert((int)(expression), #expression, __FILE__, __LINE__);
 * #endif
 *
 * void increment_value(int * const value) {
 *     assert(value);
 *     (*value) ++;
 * }
 * @endcode
 *
 * @see assert(3)
 * @see expect_assert_failure
 */
void mock_assert(const int result, const char* const expression,
                 const char * const file, const int line);

#ifdef DOXYGEN
/**
 * @brief Ensure that mock_assert() is called.
 *
 * If mock_assert() is called the assert expression string is returned.
 *
 * @param[in]  fn_call  The function will will call mock_assert().
 *
 * @code
 * #define assert mock_assert
 *
 * void showmessage(const char *message) {
 *   assert(message);
 * }
 *
 * int main(int argc, const char* argv[]) {
 *   expect_assert_failure(show_message(NULL));
 *   printf("succeeded\n");
 *   return 0;
 * }
 * @endcode
 *
 */
void expect_assert_failure(function fn_call);
#else
#define expect_assert_failure(function_call) \
  { \
    const int result = setjmp(global_expect_assert_env); \
    global_expecting_assert = 1; \
    if (result) { \
      print_message("Expected assertion %s occurred\n", \
                    global_last_failed_assert); \
      global_expecting_assert = 0; \
    } else { \
      function_call ; \
      global_expecting_assert = 0; \
      print_error("Expected assert in %s\n", #function_call); \
      _fail(__FILE__, __LINE__); \
    } \
  }
#endif

/** @} */

/* Function prototype for setup, test and teardown functions. */
typedef void (*UnitTestFunction)(void **state);

/* Function that determines whether a function parameter value is correct. */
typedef int (*CheckParameterValue)(const LargestIntegralType value,
                                   const LargestIntegralType check_value_data);

/* Type of the unit test function. */
typedef enum UnitTestFunctionType {
    UNIT_TEST_FUNCTION_TYPE_TEST = 0,
    UNIT_TEST_FUNCTION_TYPE_SETUP,
    UNIT_TEST_FUNCTION_TYPE_TEARDOWN,
    UNIT_TEST_FUNCTION_TYPE_GROUP_SETUP,
    UNIT_TEST_FUNCTION_TYPE_GROUP_TEARDOWN,
} UnitTestFunctionType;

/*
 * Stores a unit test function with its name and type.
 * NOTE: Every setup function must be paired with a teardown function.  It's
 * possible to specify NULL function pointers.
 */
typedef struct UnitTest {
    const char* name;
    UnitTestFunction function;
    UnitTestFunctionType function_type;
} UnitTest;

typedef struct GroupTest {
    UnitTestFunction setup;
    UnitTestFunction teardown;
    const UnitTest *tests;
    const size_t number_of_tests;
} GroupTest;

/* Function prototype for test functions. */
typedef void (*CMUnitTestFunction)(void **state);

/* Function prototype for setup and teardown functions. */
typedef int (*CMFixtureFunction)(void **state);

struct CMUnitTest {
    const char *name;
    CMUnitTestFunction test_func;
    CMFixtureFunction setup_func;
    CMFixtureFunction teardown_func;
};

/* Location within some source code. */
typedef struct SourceLocation {
    const char* file;
    int line;
} SourceLocation;

/* Event that's called to check a parameter value. */
typedef struct CheckParameterEvent {
    SourceLocation location;
    const char *parameter_name;
    CheckParameterValue check_value;
    LargestIntegralType check_value_data;
} CheckParameterEvent;

/* Used by expect_assert_failure() and mock_assert(). */
extern int global_expecting_assert;
//extern jmp_buf global_expect_assert_env;
extern const char * global_last_failed_assert;

/* Retrieves a value for the given function, as set by "will_return". */
LargestIntegralType _mock(const char * const function, const char* const file,
                          const int line);

void _expect_check(
    const char* const function, const char* const parameter,
    const char* const file, const int line,
    const CheckParameterValue check_function,
    const LargestIntegralType check_data, CheckParameterEvent * const event,
    const int count);

void _expect_in_set(
    const char* const function, const char* const parameter,
    const char* const file, const int line, const LargestIntegralType values[],
    const size_t number_of_values, const int count);
void _expect_not_in_set(
    const char* const function, const char* const parameter,
    const char* const file, const int line, const LargestIntegralType values[],
    const size_t number_of_values, const int count);

void _expect_in_range(
    const char* const function, const char* const parameter,
    const char* const file, const int line,
    const LargestIntegralType minimum,
    const LargestIntegralType maximum, const int count);
void _expect_not_in_range(
    const char* const function, const char* const parameter,
    const char* const file, const int line,
    const LargestIntegralType minimum,
    const LargestIntegralType maximum, const int count);

void _expect_value(
    const char* const function, const char* const parameter,
    const char* const file, const int line, const LargestIntegralType value,
    const int count);
void _expect_not_value(
    const char* const function, const char* const parameter,
    const char* const file, const int line, const LargestIntegralType value,
    const int count);

void _expect_string(
    const char* const function, const char* const parameter,
    const char* const file, const int line, const char* string,
    const int count);
void _expect_not_string(
    const char* const function, const char* const parameter,
    const char* const file, const int line, const char* string,
    const int count);

void _expect_memory(
    const char* const function, const char* const parameter,
    const char* const file, const int line, const void* const memory,
    const size_t size, const int count);
void _expect_not_memory(
    const char* const function, const char* const parameter,
    const char* const file, const int line, const void* const memory,
    const size_t size, const int count);

void _expect_any(
    const char* const function, const char* const parameter,
    const char* const file, const int line, const int count);

void _check_expected(
    const char * const function_name, const char * const parameter_name,
    const char* file, const int line, const LargestIntegralType value);

void _will_return(const char * const function_name, const char * const file,
                  const int line, const LargestIntegralType value,
                  const int count);
void _assert_true(const LargestIntegralType result,
                  const char* const expression,
                  const char * const file, const int line);
void _assert_return_code(const LargestIntegralType result,
                         size_t rlen,
                         const LargestIntegralType error,
                         const char * const expression,
                         const char * const file,
                         const int line);
void _assert_int_equal(
    const LargestIntegralType a, const LargestIntegralType b,
    const char * const file, const int line);
void _assert_int_not_equal(
    const LargestIntegralType a, const LargestIntegralType b,
    const char * const file, const int line);
void _assert_string_equal(const char * const a, const char * const b,
                          const char * const file, const int line);
void _assert_string_not_equal(const char * const a, const char * const b,
                              const char *file, const int line);
void _assert_memory_equal(const void * const a, const void * const b,
                          const size_t size, const char* const file,
                          const int line);
void _assert_memory_not_equal(const void * const a, const void * const b,
                              const size_t size, const char* const file,
                              const int line);
void _assert_in_range(
    const LargestIntegralType value, const LargestIntegralType minimum,
    const LargestIntegralType maximum, const char* const file, const int line);
void _assert_not_in_range(
    const LargestIntegralType value, const LargestIntegralType minimum,
    const LargestIntegralType maximum, const char* const file, const int line);
void _assert_in_set(
    const LargestIntegralType value, const LargestIntegralType values[],
    const size_t number_of_values, const char* const file, const int line);
void _assert_not_in_set(
    const LargestIntegralType value, const LargestIntegralType values[],
    const size_t number_of_values, const char* const file, const int line);

void* _test_malloc(const size_t size, const char* file, const int line);
void* _test_realloc(void *ptr, const size_t size, const char* file, const int line);
void* _test_calloc(const size_t number_of_elements, const size_t size,
                   const char* file, const int line);
void _test_free(void* const ptr, const char* file, const int line);

void _fail(const char * const file, const int line);

void _skip(const char * const file, const int line);

int _run_test(
    const char * const function_name, const UnitTestFunction Function,
    void ** const volatile state, const UnitTestFunctionType function_type,
    const void* const heap_check_point);
CMOCKA_DEPRECATED int _run_tests(const UnitTest * const tests,
                                 const size_t number_of_tests);
CMOCKA_DEPRECATED int _run_group_tests(const UnitTest * const tests,
                                       const size_t number_of_tests);

/* Test runner */
int _cmocka_run_group_tests(const char *group_name,
                            const struct CMUnitTest * const tests,
                            const size_t num_tests,
                            CMFixtureFunction group_setup,
                            CMFixtureFunction group_teardown);

/* Standard output and error print methods. */
void print_message(const char* const format, ...) CMOCKA_PRINTF_ATTRIBUTE(1, 2);
void print_error(const char* const format, ...) CMOCKA_PRINTF_ATTRIBUTE(1, 2);
void vprint_message(const char* const format, va_list args) CMOCKA_PRINTF_ATTRIBUTE(1, 0);
void vprint_error(const char* const format, va_list args) CMOCKA_PRINTF_ATTRIBUTE(1, 0);

enum cm_message_output {
    CM_OUTPUT_STDOUT,
    CM_OUTPUT_SUBUNIT,
    CM_OUTPUT_TAP,
    CM_OUTPUT_XML,
};

/**
 * @brief Function to set the output format for a test.
 *
 * The ouput format for the test can either be set globally using this
 * function or overriden with environment variable CMOCKA_MESSAGE_OUTPUT.
 *
 * The environment variable can be set to either STDOUT, SUBUNIT, TAP or XML.
 *
 * @param[in] output    The output format to use for the test.
 *
 */
void cmocka_set_message_output(enum cm_message_output output);

/** @} */

#endif /* CMOCKA_H_ *//*
 * Copyright 2014 Luis Pabon, Jr.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * Programming by Contract is a programming methodology
 * which binds the caller and the function called to a
 * contract. The contract is represented using Hoare Triple:
 *      {P} C {Q}
 * where {P} is the precondition before executing command C,
 * and {Q} is the postcondition.
 *
 * See also:
 * http://en.wikipedia.org/wiki/Design_by_contract
 * http://en.wikipedia.org/wiki/Hoare_logic
 * http://dlang.org/dbc.html
 */
#ifndef CMOCKA_PBC_H_
#define CMOCKA_PBC_H_

#if defined(UNIT_TESTING) || defined (DEBUG)

#include <assert.h>

/*
 * Checks caller responsibility against contract
 */
#define REQUIRE(cond) assert(cond)

/*
 * Checks function reponsability against contract.
 */
#define ENSURE(cond) assert(cond)

/*
 * While REQUIRE and ENSURE apply to functions, INVARIANT
 * applies to classes/structs.  It ensures that intances
 * of the class/struct are consistent. In other words,
 * that the instance has not been corrupted.
 */
#define INVARIANT(invariant_fnc) do{ (invariant_fnc) } while (0);

#else
#define REQUIRE(cond) do { } while (0);
#define ENSURE(cond) do { } while (0);
#define INVARIANT(invariant_fnc) do{ } while (0);

#endif /* defined(UNIT_TESTING) || defined (DEBUG) */
#endif /* CMOCKA_PBC_H_ *//*
 * Copyright 2008 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef CMOCKA_PRIVATE_H_
#define CMOCKA_PRIVATE_H_

//#include "config.h"

#include <stdint.h>

#ifdef _WIN32
#include <windows.h>

# ifdef _MSC_VER
# include <stdio.h> /* _snprintf */

#  undef inline
#  define inline __inline

#  define strcasecmp _stricmp
#  define strncasecmp _strnicmp

#  if defined(HAVE__SNPRINTF_S)
#   undef snprintf
#   define snprintf(d, n, ...) _snprintf_s((d), (n), _TRUNCATE, __VA_ARGS__)
#  else /* HAVE__SNPRINTF_S */
#   if defined(HAVE__SNPRINTF)
#     undef snprintf
#     define snprintf _snprintf
#   else /* HAVE__SNPRINTF */
#    if !defined(HAVE_SNPRINTF)
#     error "no snprintf compatible function found"
#    endif /* HAVE_SNPRINTF */
#   endif /* HAVE__SNPRINTF */
#  endif /* HAVE__SNPRINTF_S */

#  if defined(HAVE__VSNPRINTF_S)
#   undef vsnprintf
#   define vsnprintf(s, n, f, v) _vsnprintf_s((s), (n), _TRUNCATE, (f), (v))
#  else /* HAVE__VSNPRINTF_S */
#   if defined(HAVE__VSNPRINTF)
#    undef vsnprintf
#    define vsnprintf _vsnprintf
#   else
#    if !defined(HAVE_VSNPRINTF)
#     error "No vsnprintf compatible function found"
#    endif /* HAVE_VSNPRINTF */
#   endif /* HAVE__VSNPRINTF */
#  endif /* HAVE__VSNPRINTF_S */
# endif /* _MSC_VER */

/*
 * Backwards compatibility with headers shipped with Visual Studio 2005 and
 * earlier.
 */
WINBASEAPI BOOL WINAPI IsDebuggerPresent(VOID);

#ifndef PRIdS
# define PRIdS "Id"
#endif

#ifndef PRIu64
# define PRIu64 "I64u"
#endif

#ifndef PRIuMAX
# define PRIuMAX PRIu64
#endif

#ifndef PRIxMAX
#define PRIxMAX "I64x"
#endif

#ifndef PRIXMAX
#define PRIXMAX "I64X"
#endif

#else /* _WIN32 */

#ifndef __PRI64_PREFIX
# if __WORDSIZE == 64
#  define __PRI64_PREFIX "l"
# else
#  define __PRI64_PREFIX "ll"
# endif
#endif

#ifndef PRIdS
# define PRIdS "zd"
#endif

#ifndef PRIu64
# define PRIu64 __PRI64_PREFIX "u"
#endif

#ifndef PRIuMAX
# define PRIuMAX __PRI64_PREFIX "u"
#endif

#ifndef PRIxMAX
#define PRIxMAX __PRI64_PREFIX "x"
#endif

#ifndef PRIXMAX
#define PRIXMAX __PRI64_PREFIX "X"
#endif

#endif /* _WIN32 */

/** Free memory space */
#define SAFE_FREE(x) do { if ((x) != NULL) {free(x); x=NULL;} } while(0)

/** Zero a structure */
#define ZERO_STRUCT(x) memset((char *)&(x), 0, sizeof(x))

/** Zero a structure given a pointer to the structure */
#define ZERO_STRUCTP(x) do { if ((x) != NULL) memset((char *)(x), 0, sizeof(*(x))); } while(0)

/** Get the size of an array */
#define ARRAY_SIZE(a) (sizeof(a)/sizeof(a[0]))

/** Overwrite the complete string with 'X' */
#define BURN_STRING(x) do { if ((x) != NULL) memset((x), 'X', strlen((x))); } while(0)

/**
 * This is a hack to fix warnings. The idea is to use this everywhere that we
 * get the "discarding const" warning by the compiler. That doesn't actually
 * fix the real issue, but marks the place and you can search the code for
 * discard_const.
 *
 * Please use this macro only when there is no other way to fix the warning.
 * We should use this function in only in a very few places.
 *
 * Also, please call this via the discard_const_p() macro interface, as that
 * makes the return type safe.
 */
#define discard_const(ptr) ((void *)((uintptr_t)(ptr)))

/**
 * Type-safe version of discard_const
 */
#define discard_const_p(type, ptr) ((type *)discard_const(ptr))

#endif /* CMOCKA_PRIVATE_H_ *//**
 * @file lightSensor.c
 * @author Shreya Chakraborty
 * @brief APDS9301 sensor register functions
 * @version 0.1
 * @date 2019-03-31
 * 
 * @copyright Copyright (c) 2019
 * 
 */
#include "includes.h"
#include "lightSensor.h"
#include "myI2C.h"
#include "logger.h"

int APDS9301_getCh0(uint16_t *data)
{
    int ret1,ret2;
    uint8_t datalow, datahigh;
    ret1 = I2C_read_byte(&i2c_handler,APDS9301_SLAVE_ADDRESS, APDS9301_CH0_DATALOW_REG, &datalow);
    ret1 += I2C_read_byte(&i2c_handler,APDS9301_SLAVE_ADDRESS, APDS9301_CH0_DATAHIGH_REG, &datahigh);
    if(ret1)
    {
        LOG_ERROR(LIGHT_TASK,"APDS getch0 failed");
        return EXIT_FAILURE;
    }
    *data = (((uint16_t)datahigh) << 8) | datalow ;
    LOG_DEBUG(LIGHT_TASK,"Value of ch0 is %d",*data);
    return EXIT_SUCCESS;
}

int APDS9301_getCh1(uint16_t *data)
{
    int ret1;
    uint8_t datalow, datahigh;
    ret1 = I2C_read_byte(&i2c_handler,APDS9301_SLAVE_ADDRESS, APDS9301_CH1_DATALOW_REG, &datalow);
    ret1 += I2C_read_byte(&i2c_handler,APDS9301_SLAVE_ADDRESS, APDS9301_CH1_DATAHIGH_REG, &datahigh);
    if(ret1)
    {
        LOG_ERROR(LIGHT_TASK,"APDS getch1 failed");
        return EXIT_FAILURE;
    }
    *data = (((uint16_t)datahigh) << 8) | datalow ;
    LOG_DEBUG(LIGHT_TASK,"Value of ch1 is %d",*data);
    return EXIT_SUCCESS;

}

int APDS9301_getlight(float *lux)
{
    uint16_t ch1_data , ch0_data;
    float val = 0.0;
    int ret1 = 0;
    ret1 = APDS9301_getCh0(&ch0_data);
    ret1 += APDS9301_getCh1(&ch1_data);
    if(ret1)
    {
        LOG_ERROR(LIGHT_TASK,"getLight failed");
        return EXIT_FAILURE;
    }
    //LOG_DEBUG(LIGHT_TASK,"CH0 val is %d",ch0_data);
    //LOG_DEBUG(LIGHT_TASK,"CH1 val is %d",ch1_data);
    if(!(ch0_data))
    {
        LOG_ERROR(LIGHT_TASK,"channel 0 val is 0");
        return EXIT_FAILURE;
    }

    val = (float)ch1_data/(float)ch0_data;   
    if(val > 0 && val <= 0.50)
    {
        *lux = (0.0304*ch0_data) - (0.062*ch0_data*(pow(val, 1.4)));
    }
    else if(val > 0.50 && val <= 0.61)
    {
        *lux = (0.0224*ch0_data) - (0.031*ch1_data);
    }
    else if(val > 0.61 && val <= 0.80)
    {
        *lux = (0.0128*ch0_data) - (0.0153*ch1_data);
    }
    else if(val > 0.80 && val <= 1.30)
    {
        *lux = (0.00146*ch0_data) - (0.00112*ch1_data);
    }
    else //val > 1.30
    {
        *lux = 0.0;
    }
    return EXIT_SUCCESS;
}

int APDS9301_powerup()
{
    int ret1;
    ret1 = I2C_write_byte_data(&i2c_handler,APDS9301_SLAVE_ADDRESS,APDS9301_CONTROL_REG,APDS9301_CONTROL_POWER_UP);
    if(ret1)
    {
        return EXIT_FAILURE;
    }
    uint8_t data = 0;
    ret1 = I2C_read_byte(&i2c_handler,APDS9301_SLAVE_ADDRESS,APDS9301_CONTROL_REG, &data);
    LOG_DEBUG(LIGHT_TASK, "Power Up state:0x%x",data);
    if(ret1 || (data & 0x03) != 0x03)
    {
        return EXIT_FAILURE;
    }
    return EXIT_SUCCESS;
}

int APDS9301_intClear(void)
{
    int ret1;
    ret1 = I2C_write_byte(&i2c_handler,APDS9301_SLAVE_ADDRESS,APDS9301_CONTROL_REG | APDS9301_COMMAND_INT_CLEAR);
    if(ret1)
    {
        return EXIT_FAILURE;
    } 
    return EXIT_SUCCESS;   
}

int APDS9301_CheckInt(uint8_t *data)
{
    int ret1;
    ret1 = I2C_read_byte(&i2c_handler,APDS9301_SLAVE_ADDRESS,APDS9301_CONTROL_REG,data);
    *data &= (APDS9301_COMMAND_INT_CLEAR);
    *data = *data >> 6;
    if(*data)
    {
        printf("interrupt cleared\n");
    }
    else
    {
        printf("pending interrupt");
    }
    
    if(ret1)
    {
        return EXIT_FAILURE;
    } 
    return EXIT_SUCCESS;   
}
int APDS9301_readIDreg(uint8_t *data)
{
    int ret1;
    ret1 = I2C_read_byte(&i2c_handler,APDS9301_SLAVE_ADDRESS,APDS9301_ID_REG,data);
    if(ret1)
    {
        return EXIT_FAILURE;
    }
    return EXIT_SUCCESS;
}

int APDS9301_writeCMDreg(uint8_t data) // also write command register
{
    int ret1;
    ret1 = I2C_write_byte_data(&i2c_handler,APDS9301_SLAVE_ADDRESS,APDS9301_CONTROL_REG,data);
    if(ret1)
    {
        return EXIT_FAILURE;
    } 
    return EXIT_SUCCESS;  
}

int APDS9301_readCTRLreg(uint8_t *data)
{
    int ret1;
    ret1 = I2C_read_byte(&i2c_handler,APDS9301_SLAVE_ADDRESS,APDS9301_CONTROL_REG,data);
    if(ret1)
    {
        return EXIT_FAILURE;
    }
    return EXIT_SUCCESS;
}

int APDS9301_setTiming_gain(gain_mode_t gain) //default value is low
{
    uint8_t result;
    int ret1 = I2C_read_byte(&i2c_handler,APDS9301_SLAVE_ADDRESS,APDS9301_TIMING_REG,&result);
    if(ret1)
    {
        return EXIT_FAILURE;
    }
    
    if(gain == LOW)
    {
        result &= ~((uint8_t)APDS9301_TIMING_GAIN);
    }
    else if (gain == HIGH) // gain is high
    {
        result |= (uint8_t)APDS9301_TIMING_GAIN;
    }
    else //error
    {
        return EXIT_FAILURE;
    }
    ret1 = I2C_write_byte_data(&i2c_handler, APDS9301_SLAVE_ADDRESS, APDS9301_TIMING_REG,result);
    if(ret1)
    {
        return EXIT_FAILURE;
    } 
    return EXIT_SUCCESS;  
}

int APDS9301_setTiming_integ(integ_time_t integTime) //mode 2 is default
{
    uint8_t result;
    int ret1 = I2C_read_byte(&i2c_handler,APDS9301_SLAVE_ADDRESS,APDS9301_TIMING_REG,&result);
    if(ret1)
    {
        return EXIT_FAILURE;
    }

    if(integTime == MODE_ZERO)
    {
        result &= ~((uint8_t)APDS9301_TIMING_INTEGRATION_TIME_BIT0);
        result &= ~((uint8_t)APDS9301_TIMING_INTEGRATION_TIME_BIT1);
    }
    else if(integTime == MODE_ONE)
    {
        result &= ~((uint8_t)APDS9301_TIMING_INTEGRATION_TIME_BIT1);
        result |= (uint8_t)APDS9301_TIMING_INTEGRATION_TIME_BIT0;
    }
    else if(integTime == MODE_TWO)
    {
        result |= (uint8_t)APDS9301_TIMING_INTEGRATION_TIME_BIT1;
        result &= ~((uint8_t)APDS9301_TIMING_INTEGRATION_TIME_BIT0);
    }
    else
    {
        result |= (uint8_t)APDS9301_TIMING_INTEGRATION_TIME_BIT0;
        result |= (uint8_t)APDS9301_TIMING_INTEGRATION_TIME_BIT1;
    }
    ret1 = I2C_write_byte_data(&i2c_handler, APDS9301_SLAVE_ADDRESS, APDS9301_TIMING_REG,result);
    if(ret1)
    {
        return EXIT_FAILURE;
    } 
    return EXIT_SUCCESS;  
      
}

int APDS9301_interruptCTRLreg(interrupt_mode_t option) //default is disabled
{
    uint8_t result;
    int ret1 = I2C_read_byte(&i2c_handler,APDS9301_SLAVE_ADDRESS,APDS9301_INTERRUPT_REG,&result);
    if(ret1)
    {
        return EXIT_FAILURE;
    }

    if(option == ENABLE)
    {
        result |= ((uint8_t)APDS9301_INTERRUPT_CTRL_ENABLE_DISABLE | (0x1));
    }
    else
    {
        result &= ~((uint8_t)APDS9301_INTERRUPT_CTRL_ENABLE_DISABLE);    
    }
    ret1 = I2C_write_byte_data(&i2c_handler, APDS9301_SLAVE_ADDRESS, APDS9301_INTERRUPT_REG,result);
    if(ret1)
    {
        return EXIT_FAILURE;
    } 
    return EXIT_SUCCESS;   
}

int APDS9301_writeTHRESH_lowlow(uint16_t th_lowlow)
{
    int ret1 = I2C_write_word(&i2c_handler, APDS9301_SLAVE_ADDRESS,APDS9301_THRESHLOWLOW_REG | APDS9301_COMMAND_WORD_RW,th_lowlow);
    if(ret1)
    {
        return EXIT_FAILURE;
    } 
    return EXIT_SUCCESS;   
}
int APDS9301_readTHRESH_lowlow(uint8_t *th_lowlow)
{
    int ret1 = I2C_read_byte(&i2c_handler, APDS9301_SLAVE_ADDRESS,APDS9301_THRESHLOWLOW_REG,th_lowlow);
    if(ret1)
    {
        return EXIT_FAILURE;
    } 
    return EXIT_SUCCESS;    
}
int APDS9301_writeTHRESH_highlow(uint16_t th_hilow)
{
    int ret1 = I2C_write_word(&i2c_handler, APDS9301_SLAVE_ADDRESS,APDS9301_THRESHHILOW_REG | APDS9301_COMMAND_WORD_RW,th_hilow);
    if(ret1)
    {
        return EXIT_FAILURE;
    } 
    return EXIT_SUCCESS;     
}
int APDS9301_readTHRESH_highlow(uint8_t *th_hilow)
{
    int ret1 = I2C_read_byte(&i2c_handler, APDS9301_SLAVE_ADDRESS,APDS9301_THRESHHILOW_REG,th_hilow);
    if(ret1)
    {
        return EXIT_FAILURE;
    } 
    return EXIT_SUCCESS;     
}

int APDS9301_readTHRESH_highhigh(uint8_t *th_hihi)
{
    int ret1 = I2C_read_byte(&i2c_handler, APDS9301_SLAVE_ADDRESS,APDS9301_THRESHHIHI_REG,th_hihi);
    if(ret1)
    {
        return EXIT_FAILURE;
    } 
    return EXIT_SUCCESS;     
}

int APDS9301_readTHRESH_lowhigh(uint8_t *th_lowhi)
{
    int ret1 = I2C_read_byte(&i2c_handler, APDS9301_SLAVE_ADDRESS,APDS9301_THRESHLOWHI_REG,th_lowhi);
    if(ret1)
    {
        return EXIT_FAILURE;
    } 
    return EXIT_SUCCESS;     
}

int APDS9301_setAllDefault()
{
    int ret = APDS9301_setTiming_gain(LOW);
    ret |=  APDS9301_setTiming_integ(MODE_TWO);
    ret |= APDS9301_interruptCTRLreg(DISABLE);
    if(ret)
    {
        return EXIT_FAILURE;
    } 
    return EXIT_SUCCESS;  
}/**
 * @file i2c.c
 * @author Shreya Chakraborty
 * @brief I2C driver functions for the sensor
 * @version 0.1
 * @date 2019-03-22
 * @reference https://gist.github.com/JamesDunne/9b7fbedb74c22ccc833059623f47beb7
 * https://bunniestudios.com/blog/images/infocast_i2c.c
 * @copyright Copyright (c) 2019
 * 
 */
#include <stdio.h>
#include <linux/i2c.h>
#include <linux/i2c-dev.h>
#include <fcntl.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <string.h>
#include "i2c.h"

// Global file descriptor used to talk to the I2C bus:
int i2c_fd = -1;

const char *i2c_fname = "/dev/i2c-2"; //pins p9_19 and p9_20

// Returns a new file descriptor for communicating with the I2C bus:
int i2c_init(void) {
    if ((i2c_fd = open(i2c_fname, O_RDWR)) < 0) {
        char err[200];
        sprintf(err, "open('%s') in i2c_init", i2c_fname);
        perror(err);
        return -1;
    }
    return i2c_fd;
}

void i2c_close(void) {
    close(i2c_fd);
}

// Write to an I2C slave device's register:
int i2c_write(uint8_t slave_addr, uint8_t reg, uint8_t data) {
    int retval;
    uint8_t outbuf[2];

    struct i2c_msg msgs[1];
    struct i2c_rdwr_ioctl_data msgset[1];

    outbuf[0] = reg;
    outbuf[1] = data;

    msgs[0].addr = slave_addr;
    msgs[0].flags = 0;
    msgs[0].len = 2;
    msgs[0].buf = outbuf;

    msgset[0].msgs = msgs;
    msgset[0].nmsgs = 1;

    if (ioctl(i2c_fd, I2C_RDWR, &msgset) < 0) {
        perror("ioctl(I2C_RDWR) in i2c_write");
        return -1;
    }

    return 0;
}

// Read the given I2C slave device's register and return the read value in `*result`:
int i2c_read(uint8_t slave_addr, uint8_t reg, uint8_t *result) {
    int retval;
    uint8_t outbuf[1], inbuf[1];
    struct i2c_msg msgs[2];
    struct i2c_rdwr_ioctl_data msgset[1];

    msgs[0].addr = slave_addr;
    msgs[0].flags = 0;
    msgs[0].len = 1;
    msgs[0].buf = outbuf;

    msgs[1].addr = slave_addr;
    msgs[1].flags = I2C_M_RD | I2C_M_NOSTART;
    msgs[1].len = 1;
    msgs[1].buf = inbuf;

    msgset[0].msgs = msgs;
    msgset[0].nmsgs = 2;

    outbuf[0] = reg;

    inbuf[0] = 0;

    *result = 0;
    if (ioctl(i2c_fd, I2C_RDWR, &msgset) < 0) {
        perror("ioctl(I2C_RDWR) in i2c_read");
        return -1;
    }
    *result = inbuf[0];
    return 0;
}/**
 * @file bist.c
 * @author Shreya Chakraborty
 * @brief built in self test before starting the main program
 * @version 0.1
 * @date 2019-03-16
 * 
 * @copyright Copyright (c) 2019
 * 
 */
#include "includes.h"
#include "bist.h"
#include "logger.h"
#include "main.h"
#include "bbgled.h"
#include "mysignal.h"
#include "lightSensor.h"
#include "tempSensor.h"
#include "myI2C.h"

extern int thread_flags[5];
static volatile uint32_t BIST_allOk = 0;
// static pthread_mutex_t bistlock = PTHREAD_MUTEX_INITIALIZER;

int Test_LightSensor(void)
{
    int ret = 0;
    uint8_t data;
    ret = APDS9301_powerup();
    LOG_DEBUG(BIST_TASK, "Light Sensor(ID:0x%1x) powered up",data);
    ret += APDS9301_readIDreg(&data); 
    LOG_DEBUG(BIST_TASK,"Testing Light Sensor ID reg 0x%1x",data);
    if(ret)
    {
        return EXIT_FAILURE;
    }
    if((data & 0xF0) != 0x50)
    {
        return EXIT_FAILURE;
    }
    return EXIT_SUCCESS;
}

int Test_AllThreads(void)
{
    int combined_flag = 1;
    for(int i = 0; i < MAX_TASKS; i++)
    {
        if(!thread_flag[i])
        {
            PRINTLOGCONSOLE("%s thread has not been spawned",moduleIdName[i]);
        }
        combined_flag &= thread_flag[i];
    }
    if (!combined_flag)
    {
        return EXIT_FAILURE;
    }
    return EXIT_SUCCESS;    
}

int Test_I2C(void)
{
    int ret = I2C_init(&i2c_handler);
    return ret;
}

int Test_TempSensor(void)
{
    float temp_val;
    TMP102_getTemperature(&temp_val);
    if((temp_val > 128) || (temp_val < -40) || (temp_val == 0.0))
    {
        return EXIT_FAILURE;
    }
    return EXIT_SUCCESS;
}

int Test_loggerQ(void)
{
    int ret = LOG_ENQUEUE(LOG_DEBUG,BIST_TASK, "Testing Logger Queue");
    if(ret != 0)
    {
        return EXIT_FAILURE;
    }
    return EXIT_SUCCESS;
}

int BuiltInSelfTest(void)
{
    int ret;
    ret = Test_loggerQ();
    if(!ret)
    {
        PRINTLOGCONSOLE("Logger Queue is functional");   
    }
    else
    {
        PRINTLOGCONSOLE("Logger Queue is NOT functional"); 
    }
    int ret1 = Test_I2C();
    if(!ret1)
    {
        PRINTLOGCONSOLE("I2C bus initialisation Successfull");   
    }
    else
    {
        PRINTLOGCONSOLE("I2C bus initialisation NOT Successfull"); 
    }
    int ret2 = Test_AllThreads();
    if(!ret2)
    {
        PRINTLOGCONSOLE("All threads created and functional");   
    }
    else
    {
        PRINTLOGCONSOLE("Some thread/threads were mot created successfully");      
    }
    int ret3 = Test_LightSensor();
    if(!ret3)
    {
        PRINTLOGCONSOLE("Light Sensor connected and functional");   
    }
    else
    {
        PRINTLOGCONSOLE("Light Sensor disconnected and non functional");     
    }
    int ret4 = Test_TempSensor();
    if(!ret4)
    {
        PRINTLOGCONSOLE("Temp Sensor connected and functional");   
    }
    else
    {
        PRINTLOGCONSOLE("Temp Sensor disconnected and non functional");  
    }
    return (ret|ret1|ret2|ret3|ret4);
}

int CheckBistResult(void)
{
    //int ret;
    // pthread_mutex_lock(&bistlock);
    //ret = BIST_allOk;
    // pthread_mutex_unlock(&bistlock);
    if(BIST_allOk)
    {
        LOG_DEBUG(BIST_TASK,"Built in Self Test Passed");
    }
    return BIST_allOk;   
}

void PostBistOkResult(void)
{
    sem_post(&logger_thread_sem);
    sem_post(&temp_thread_sem);
    sem_post(&light_thread_sem);
    sem_post(&socket_thread_sem); 
}

void *bist_task(void *threadp)
{
    PRINT("\n******BIST TASK******\n");
    PRINTLOGCONSOLE("-----Built in Self Test started-----");
    int ret = BuiltInSelfTest();
    if(ret)
    {
        BIST_allOk = 0;
        // PRINTLOGCONSOLE("Program Exiting.....");
    }
    else
    {
        //pthread_mutex_lock(&bistlock);
        BIST_allOk = 1;
        //pthread_mutex_unlock(&bistlock);
    }
    PRINTLOGCONSOLE("-----Built in Self Test Ended-----");
    PRINT("******BIST TASK END******\n\n");
    return NULL;
}/**
 * @file mysignal.c
 * @author Shreya Chakraborty
 * @brief handles the CTRL-C keyboard input from user to exit cleanly
 * @version 0.1
 * @date 2019-03-31
 * 
 * @copyright Copyright (c) 2019
 * 
 */
#include "includes.h"
#include "bbgled.h"
#include "mysignal.h"
#include "heartbeat.h"
#include "logger.h"


void signal_handler(int signum)
{
    if (signum == SIGINT)
    {
        LOG_WARN(MAIN_TASK,"User exit signal received....");
        SystemExit();
    }
    
}
/**
 * @file bbgled.c
 * @author your name (you@domain.com)
 * @brief 
 * @version 0.1
 * @date 2019-03-20
 * @Reference https://www.teachmemicro.com/beaglebone-black-blink-led-using-c/ 
 * @copyright Copyright (c) 2019
 * 
 */
#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include "logger.h"
#include "bbgled.h"
#include "includes.h"

static bool RED_currentState = false;
static bool GREEN_currentState = false;

int redLed_OnOff(bool option)
{
    // if(RED_currentState == option){
    //     return 0;
    // }
    char low[] = "0"; // value low led off
    char high[] = "1"; //value high led on
    char dir[] = "out"; //direction 
    char lederr[] = "26";//p8_14 led red 
    //exports gpio 26 to be confugued for red led
    FILE *export_file = fopen ("/sys/class/gpio/export", "w");
    if(export_file == NULL)
    {
        return -1;
    }
    fwrite (lederr, 1, sizeof(lederr), export_file);
    fclose (export_file); 
    //this part here sets the direction of the pin
    FILE *IO_direction = fopen("/sys/class/gpio/gpio26/direction", "w");
    if(IO_direction == NULL)
    {
        return -1;
    }
    fwrite(dir, 1, sizeof(dir), IO_direction); //set the pin to HIGH
    fclose(IO_direction);
    //turning on red led gpio 26, writing value 1
    FILE *IO_value = fopen ("/sys/class/gpio/gpio26/value", "w");
    if(IO_value == NULL)
    {
        return -1;
    }
    if(option == 1)
    {
        fwrite (high, 1, sizeof(high), IO_value); //set the pin to HIGH
    }
    else{
        fwrite (low, 1, sizeof(low), IO_value); //set the pin to HIGH
    }
    fclose (IO_value);
    RED_currentState = option;
    return 0;
}

int greenLed_OnOff(bool option)
{
    // if(GREEN_currentState == option){
    //     return 0;
    // }
    char low[] = "0"; // value low led off
    char high[] = "1"; //value high led on
    char dir[] = "out"; //direction 
    char ledok[] = "44";//p8_12 led green
    //exports gpio 44 to be confugued for red led
    FILE *export_file = fopen ("/sys/class/gpio/export", "w");
    if(export_file == NULL)
    {
        return -1;
    }
    fwrite (ledok, 1, sizeof(ledok), export_file);
    fclose (export_file); 
    //this part here sets the direction of the pin
    FILE *IO_direction = fopen("/sys/class/gpio/gpio44/direction", "w");
    if(IO_direction == NULL)
    {
        return -1;
    }
    fwrite(dir, 1, sizeof(dir), IO_direction); //set the pin to HIGH
    fclose(IO_direction);
    //turning on red led gpio 26, writing value 1
    FILE *IO_value = fopen ("/sys/class/gpio/gpio44/value", "w");
    if(IO_value == NULL)
    {
        return -1;
    }
    if(option == 1)
    {
        fwrite (high, 1, sizeof(high), IO_value); //set the pin to HIGH
    }
    else{
        fwrite (low, 1, sizeof(low), IO_value); //set the pin to HIGH
    }
    fclose (IO_value);
    GREEN_currentState = option;
    return 0;
}

/**
 * @file heartbeat.c
 * @author Shreya Chakraborty
 * @brief heartbeat functionality from all threads
 * @version 0.1
 * @date 2019-03-31
 * 
 * @copyright Copyright (c) 2019
 * 
 */
#include "mytimer.h"
#include "main.h"
#include "logger.h"
#include "bbgled.h"
#include "temp.h"
#include "light.h"
#include "socket.h"

static volatile uint32_t g_heartbeat_taskFlags = 0;
#define h_sec 2
#define h_nsec 0
int counter = 0;
static pthread_mutex_t heartbeatFlagsLock = PTHREAD_MUTEX_INITIALIZER;

//Use this function in each thread to set the respective flag for each thread. 
//And make sure about the shifting and all
void set_heartbeatFlag(moduleId_t moduleId)
{
	pthread_mutex_lock(&heartbeatFlagsLock);
	g_heartbeat_taskFlags |= (1<<moduleId);
	pthread_mutex_unlock(&heartbeatFlagsLock);
}

void SystemExit(void)
{
	kill_temp_thread();
	kill_light_thread();
	kill_socket_thread();
	//kill_logger_thread();
}

static bool systemExitInitiated = false; //to break out of heartbeat loop

void heatbeat_timer_callback(union sigval no)
{
	if(systemExitInitiated)
	{
		return;
	}
	uint32_t copy_flags = 0;
	pthread_mutex_lock(&heartbeatFlagsLock);
	uint32_t flags = g_heartbeat_taskFlags;
	g_heartbeat_taskFlags = 0;
	pthread_mutex_unlock(&heartbeatFlagsLock);
	copy_flags = flags;
	for(int i = 1; i < MAX_TASKS-1; i++)
	{
		if(!(flags & (1<<i)))
		{
            LOG_ERROR(MAIN_TASK,"HEARTBEAT </3 </3 </3 %s thread is DEAD x_x",moduleIdName[i]);
            GREENLEDOFF();
            REDLEDON();
			systemExitInitiated = true;
			SystemExit();
			break;
		}
        else {
            flags &= ~(1<<i);
            if((flags == 0) && (copy_flags == 0x0e))
            {
                LOG_INFO(MAIN_TASK,"HEARTBEAT <3 <3 <3 All threads working");
				static uint8_t greenLedON = 0; 
				if(greenLedON)
				{
					GREENLEDON();
					greenLedON ^= 1;
				}
				else
				{
					GREENLEDOFF();
					greenLedON ^= 1;
				}
				
            }
        }
	}
}

//start this after you are sure that all the threads are up and running fine - i.e. in their while() loop
void startHearbeatCheck(void)
{
    timer_t hearbeat_timer_id;
	maketimer(&hearbeat_timer_id, &heatbeat_timer_callback);
	startTimer(hearbeat_timer_id,h_sec,h_nsec);
}

/**
 * @file temp.c
 * @author your name (you@domain.com)
 * @brief Temperature task thread functionality
 * @version 0.1
 * @date 2019-03-16
 * @reference https://github.com/jbdatko/tmp102/blob/master/tmp102.c
 * @copyright Copyright (c) 2019
 * 
 */
#include "includes.h"
#include "temp.h"
#include "main.h"
#include "logger.h"
#include "bbgled.h"
#include "mysignal.h"
#include "mytimer.h"
#include "myI2C.h"
#include "tempSensor.h"
#include "i2c.h"
#include "heartbeat.h"
#include "bist.h"

static volatile float temperature_val = 0.0;
static volatile float tlow_val = 75.0;
static volatile float thigh_val = 80.0;
static volatile bool thresholdChanged = false;
static int t_sec = 1;
static int t_nsec = 0;
static sig_atomic_t stop_thread_temp = 0;
int t_count = 0;
pthread_mutex_t temp_var_lock = PTHREAD_MUTEX_INITIALIZER;

/**
 * @brief Set the Temp Var object "temp" as the value of temperature
 * 
 * @param temp 
 */
static inline void setTempVar(float temp)
{
    pthread_mutex_lock(&temp_var_lock);
    temperature_val = temp;
    pthread_mutex_unlock(&temp_var_lock);
} 

/**
 * @brief Get the Temp Var object "temp" from the actual global
 * temperature value variable
 * 
 * @return float 
 */
static inline float getTempVar()
{
    float temp = 0;
    pthread_mutex_lock(&temp_var_lock);
    temp = temperature_val;
    pthread_mutex_unlock(&temp_var_lock);
    return temp;
} 

void kill_temp_thread(void)
{
    LOG_DEBUG(TEMP_TASK,"Temperature task exit signal received");
    stop_thread_temp = 1;    
}

float getTemperature(temp_unit unit)
{
    float temp_val = getTempVar();
    if(unit == KELVIN)
    {
        temp_val = (temp_val+273.15);
    }
    else if(unit == FARENHEIT)
    {
        temp_val = ((temp_val*9/5)+32);
    }
    return temp_val;
}

int RemoteThresholdValues(float flow,float fhigh)
{
    pthread_mutex_lock(&temp_var_lock);
    tlow_val = flow;
    thigh_val = fhigh;
    thresholdChanged = true;
    pthread_mutex_unlock(&temp_var_lock); 
    return 0;
}
int TMP102_setTempThreshold(float tlow_val,float thigh_val)
{
    uint8_t bit;
    TMP102_setThigh(thigh_val);
    TMP102_setTlow(tlow_val);
    TMP102_setResolution(R0R1_SET);
    TMP102_setFaultbits(TWO_FAULTS);
    TMP102_readAL(&bit);
    LOG_INFO(TEMP_TASK,"thresholds are %f and %f",tlow_val,thigh_val);
    if(bit == 0)
    {
        GREENLEDOFF();
        REDLEDON();
        LOG_INFO(TEMP_TASK,"Current Temperature has exceeded the upper threshold");
    }
    else
    {
        REDLEDOFF();
        GREENLEDON();
    }
    return 0;
    
}


static int readAndUpdateTemp(void)
{
    float temp_val = 0.0 ;
    /*if(t_count > 4)
    {
        stop_thread_temp = 1;   
    }*/
    int ret = TMP102_getTemperature(&temp_val);
    if(ret)
    {
        LOG_ERROR(TEMP_TASK, "TMP102 Temperature Sensor disconnected: %d", ret);
        REDLEDON();
        //t_count++;
        return ret;
    }
    REDLEDOFF();
    setTempVar(temp_val);    
    LOG_INFO(TEMP_TASK,"The temperature is %0.2f C",temp_val);
    if(thresholdChanged)
    {
        thresholdChanged = false;
        TMP102_setTempThreshold(tlow_val,thigh_val);
    }
    return 0;
}

static void giveSemSensor(union sigval no)
{
    sem_post(&temp_sem);
}

void *temp_task(void *threadp)
{
    sem_init(&temp_thread_sem,0,0);
    usleep(1000);
    sem_wait(&temp_thread_sem);
    usleep(1000);
    if(!CheckBistResult())
    {
        goto exit;
    }
    LOG_INFO(TEMP_TASK,"Temperature Task thread spawned");
    I2C_init(&i2c_handler);
    timer_t temp_timer;
    sem_init(&temp_sem,0,0);
    if(maketimer(&temp_timer, &giveSemSensor) != 0)
    {
        perror("MakeTimer fail");
    }
    LOG_DEBUG(TEMP_TASK,"The thread frequency is %d sec and %d nsec",t_sec,t_nsec);
    startTimer(temp_timer,t_sec,t_nsec);
    while(!stop_thread_temp)
    {
        set_heartbeatFlag(TEMP_TASK);
        if(sem_wait(&temp_sem) == 0)
        {
            readAndUpdateTemp();
        }
    }        
exit:    
    LOG_INFO(TEMP_TASK,"Temp task thread exiting");
    return NULL;
}/**
 * @file mytimer.c
 * @author Shreya Chakraborty
 * @brief Posix timer functions for light and temp thread and heartbeat
 * @version 0.1
 * @date 2019-03-31
 * 
 * @copyright Copyright (c) 2019
 * 
 */
#include "includes.h"
#include "mytimer.h"
#include "logger.h"
#include "temp.h"
#include "light.h"

int maketimer(timer_t *timerID, void (*callback)(union sigval))
{
    int val = 0;
    struct sigevent event;
    event.sigev_notify = SIGEV_THREAD;
    event.sigev_notify_function = callback;
    event.sigev_value.sival_ptr = NULL;
    event.sigev_notify_attributes = NULL; 
    val = timer_create(CLOCK_REALTIME, &event, timerID); 
    return val;
}

int startTimer(timer_t timerID,int sec,int nsec)
{
    int val = 0;
    struct itimerspec its;
    its.it_interval.tv_sec = sec;
    its.it_interval.tv_nsec = nsec;//500000000;
    its.it_value.tv_sec = sec;
    its.it_value.tv_nsec = nsec;//500000000;
    return timer_settime(timerID, 0, &its,0);

}

int stopTimer(timer_t timer_id)
{		
	struct itimerspec its;
	
	its.it_value.tv_sec = 0;
	its.it_value.tv_nsec = 0;
	its.it_interval.tv_sec = 0;
	its.it_interval.tv_nsec = 0;

	int ret = timer_settime(timer_id, 0, &its, 0);
	return ret;
}/**
 * @brief CMOCKA
 * 
 */
/*
 * Copyright 2008 Google Inc.
 * Copyright 2014-2015 Andreas Schneider <asn@cryptomilk.org>
 * Copyright 2015      Jakub Hrozek <jakub.hrozek@posteo.se>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#ifdef HAVE_MALLOC_H
#include <malloc.h>
#endif

#ifdef HAVE_INTTYPES_H
#include <inttypes.h>
#endif

#ifdef HAVE_SIGNAL_H
#include <signal.h>
#endif

#include <stdint.h>
#include <setjmp.h>
#include <stdarg.h>
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

/*
 * This allows to add a platform specific header file. Some embedded platforms
 * sometimes miss certain types and definitions.
 *
 * Example:
 *
 * typedef unsigned long int uintptr_t
 * #define _UINTPTR_T 1
 * #define _UINTPTR_T_DEFINED 1
 */
#ifdef CMOCKA_PLATFORM_INCLUDE
# include "cmocka_platform.h"
#endif /* CMOCKA_PLATFORM_INCLUDE */

#include <cmocka.h>
#include <cmocka_private.h>

/* Size of guard bytes around dynamically allocated blocks. */
#define MALLOC_GUARD_SIZE 16
/* Pattern used to initialize guard blocks. */
#define MALLOC_GUARD_PATTERN 0xEF
/* Pattern used to initialize memory allocated with test_malloc(). */
#define MALLOC_ALLOC_PATTERN 0xBA
#define MALLOC_FREE_PATTERN 0xCD
/* Alignment of allocated blocks.  NOTE: This must be base2. */
#define MALLOC_ALIGNMENT sizeof(size_t)

/* Printf formatting for source code locations. */
#define SOURCE_LOCATION_FORMAT "%s:%u"

#if defined(HAVE_GCC_THREAD_LOCAL_STORAGE)
# define CMOCKA_THREAD __thread
#elif defined(HAVE_MSVC_THREAD_LOCAL_STORAGE)
# define CMOCKA_THREAD __declspec(thread)
#else
# define CMOCKA_THREAD
#endif

#ifdef HAVE_CLOCK_GETTIME_REALTIME
#define CMOCKA_CLOCK_GETTIME(clock_id, ts) clock_gettime((clock_id), (ts))
#else
#define CMOCKA_CLOCK_GETTIME(clock_id, ts)
#endif

/*
 * Declare and initialize the pointer member of ValuePointer variable name
 * with ptr.
 */
#define declare_initialize_value_pointer_pointer(name, ptr) \
    ValuePointer name ; \
    name.value = 0; \
    name.x.pointer = (void*)(ptr)

/*
 * Declare and initialize the value member of ValuePointer variable name
 * with val.
 */
#define declare_initialize_value_pointer_value(name, val) \
    ValuePointer name ; \
    name.value = val

/* Cast a LargestIntegralType to pointer_type via a ValuePointer. */
#define cast_largest_integral_type_to_pointer( \
    pointer_type, largest_integral_type) \
    ((pointer_type)((ValuePointer*)&(largest_integral_type))->x.pointer)

/* Used to cast LargetIntegralType to void* and vice versa. */
typedef union ValuePointer {
    LargestIntegralType value;
    struct {
#if defined(WORDS_BIGENDIAN) && (WORDS_SIZEOF_VOID_P == 4)
        unsigned int padding;
#endif
        void *pointer;
    } x;
} ValuePointer;

/* Doubly linked list node. */
typedef struct ListNode {
    const void *value;
    int refcount;
    struct ListNode *next;
    struct ListNode *prev;
} ListNode;

/* Debug information for malloc(). */
typedef struct MallocBlockInfo {
    void* block;              /* Address of the block returned by malloc(). */
    size_t allocated_size;    /* Total size of the allocated block. */
    size_t size;              /* Request block size. */
    SourceLocation location;  /* Where the block was allocated. */
    ListNode node;            /* Node within list of all allocated blocks. */
} MallocBlockInfo;

/* State of each test. */
typedef struct TestState {
    const ListNode *check_point; /* Check point of the test if there's a */
                                 /* setup function. */
    void *state;                 /* State associated with the test. */
} TestState;

/* Determines whether two values are the same. */
typedef int (*EqualityFunction)(const void *left, const void *right);

/* Value of a symbol and the place it was declared. */
typedef struct SymbolValue {
    SourceLocation location;
    LargestIntegralType value;
} SymbolValue;

/*
 * Contains a list of values for a symbol.
 * NOTE: Each structure referenced by symbol_values_list_head must have a
 * SourceLocation as its' first member.
 */
typedef struct SymbolMapValue {
    const char *symbol_name;
    ListNode symbol_values_list_head;
} SymbolMapValue;

/* Used by list_free() to deallocate values referenced by list nodes. */
typedef void (*CleanupListValue)(const void *value, void *cleanup_value_data);

/* Structure used to check the range of integer types.a */
typedef struct CheckIntegerRange {
    CheckParameterEvent event;
    LargestIntegralType minimum;
    LargestIntegralType maximum;
} CheckIntegerRange;

/* Structure used to check whether an integer value is in a set. */
typedef struct CheckIntegerSet {
    CheckParameterEvent event;
    const LargestIntegralType *set;
    size_t size_of_set;
} CheckIntegerSet;

/* Used to check whether a parameter matches the area of memory referenced by
 * this structure.  */
typedef struct CheckMemoryData {
    CheckParameterEvent event;
    const void *memory;
    size_t size;
} CheckMemoryData;

static ListNode* list_initialize(ListNode * const node);
static ListNode* list_add(ListNode * const head, ListNode *new_node);
static ListNode* list_add_value(ListNode * const head, const void *value,
                                     const int count);
static ListNode* list_remove(
    ListNode * const node, const CleanupListValue cleanup_value,
    void * const cleanup_value_data);
static void list_remove_free(
    ListNode * const node, const CleanupListValue cleanup_value,
    void * const cleanup_value_data);
static int list_empty(const ListNode * const head);
static int list_find(
    ListNode * const head, const void *value,
    const EqualityFunction equal_func, ListNode **output);
static int list_first(ListNode * const head, ListNode **output);
static ListNode* list_free(
    ListNode * const head, const CleanupListValue cleanup_value,
    void * const cleanup_value_data);

static void add_symbol_value(
    ListNode * const symbol_map_head, const char * const symbol_names[],
    const size_t number_of_symbol_names, const void* value, const int count);
static int get_symbol_value(
    ListNode * const symbol_map_head, const char * const symbol_names[],
    const size_t number_of_symbol_names, void **output);
static void free_value(const void *value, void *cleanup_value_data);
static void free_symbol_map_value(
    const void *value, void *cleanup_value_data);
static void remove_always_return_values(ListNode * const map_head,
                                        const size_t number_of_symbol_names);
static int check_for_leftover_values(
    const ListNode * const map_head, const char * const error_message,
    const size_t number_of_symbol_names);
/*
 * This must be called at the beginning of a test to initialize some data
 * structures.
 */
static void initialize_testing(const char *test_name);

/* This must be called at the end of a test to free() allocated structures. */
static void teardown_testing(const char *test_name);

static int cm_error_message_enabled = 1;
static CMOCKA_THREAD char *cm_error_message;

void cm_print_error(const char * const format, ...) CMOCKA_PRINTF_ATTRIBUTE(1, 2);

/*
 * Keeps track of the calling context returned by setenv() so that the fail()
 * method can jump out of a test.
 */
static CMOCKA_THREAD jmp_buf global_run_test_env;
static CMOCKA_THREAD int global_running_test = 0;

/* Keeps track of the calling context returned by setenv() so that */
/* mock_assert() can optionally jump back to expect_assert_failure(). */
jmp_buf global_expect_assert_env;
int global_expecting_assert = 0;
const char *global_last_failed_assert = NULL;
static int global_skip_test;

/* Keeps a map of the values that functions will have to return to provide */
/* mocked interfaces. */
static CMOCKA_THREAD ListNode global_function_result_map_head;
/* Location of the last mock value returned was declared. */
static CMOCKA_THREAD SourceLocation global_last_mock_value_location;

/* Keeps a map of the values that functions expect as parameters to their
 * mocked interfaces. */
static CMOCKA_THREAD ListNode global_function_parameter_map_head;
/* Location of last parameter value checked was declared. */
static CMOCKA_THREAD SourceLocation global_last_parameter_location;

/* List of all currently allocated blocks. */
static CMOCKA_THREAD ListNode global_allocated_blocks;

static enum cm_message_output global_msg_output = CM_OUTPUT_STDOUT;

#ifndef _WIN32
/* Signals caught by exception_handler(). */
static const int exception_signals[] = {
    SIGFPE,
    SIGILL,
    SIGSEGV,
#ifdef SIGBUS
    SIGBUS,
#endif
#ifdef SIGSYS
    SIGSYS,
#endif
};

/* Default signal functions that should be restored after a test is complete. */
typedef void (*SignalFunction)(int signal);
static SignalFunction default_signal_functions[
    ARRAY_SIZE(exception_signals)];

#else /* _WIN32 */

/* The default exception filter. */
static LPTOP_LEVEL_EXCEPTION_FILTER previous_exception_filter;

/* Fatal exceptions. */
typedef struct ExceptionCodeInfo {
    DWORD code;
    const char* description;
} ExceptionCodeInfo;

#define EXCEPTION_CODE_INFO(exception_code) {exception_code, #exception_code}

static const ExceptionCodeInfo exception_codes[] = {
    EXCEPTION_CODE_INFO(EXCEPTION_ACCESS_VIOLATION),
    EXCEPTION_CODE_INFO(EXCEPTION_ARRAY_BOUNDS_EXCEEDED),
    EXCEPTION_CODE_INFO(EXCEPTION_DATATYPE_MISALIGNMENT),
    EXCEPTION_CODE_INFO(EXCEPTION_FLT_DENORMAL_OPERAND),
    EXCEPTION_CODE_INFO(EXCEPTION_FLT_DIVIDE_BY_ZERO),
    EXCEPTION_CODE_INFO(EXCEPTION_FLT_INEXACT_RESULT),
    EXCEPTION_CODE_INFO(EXCEPTION_FLT_INVALID_OPERATION),
    EXCEPTION_CODE_INFO(EXCEPTION_FLT_OVERFLOW),
    EXCEPTION_CODE_INFO(EXCEPTION_FLT_STACK_CHECK),
    EXCEPTION_CODE_INFO(EXCEPTION_FLT_UNDERFLOW),
    EXCEPTION_CODE_INFO(EXCEPTION_GUARD_PAGE),
    EXCEPTION_CODE_INFO(EXCEPTION_ILLEGAL_INSTRUCTION),
    EXCEPTION_CODE_INFO(EXCEPTION_INT_DIVIDE_BY_ZERO),
    EXCEPTION_CODE_INFO(EXCEPTION_INT_OVERFLOW),
    EXCEPTION_CODE_INFO(EXCEPTION_INVALID_DISPOSITION),
    EXCEPTION_CODE_INFO(EXCEPTION_INVALID_HANDLE),
    EXCEPTION_CODE_INFO(EXCEPTION_IN_PAGE_ERROR),
    EXCEPTION_CODE_INFO(EXCEPTION_NONCONTINUABLE_EXCEPTION),
    EXCEPTION_CODE_INFO(EXCEPTION_PRIV_INSTRUCTION),
    EXCEPTION_CODE_INFO(EXCEPTION_STACK_OVERFLOW),
};
#endif /* !_WIN32 */

enum CMUnitTestStatus {
    CM_TEST_NOT_STARTED,
    CM_TEST_PASSED,
    CM_TEST_FAILED,
    CM_TEST_ERROR,
    CM_TEST_SKIPPED,
};

struct CMUnitTestState {
    const ListNode *check_point; /* Check point of the test if there's a setup function. */
    const struct CMUnitTest *test; /* Point to array element in the tests we get passed */
    void *state; /* State associated with the test */
    const char *error_message; /* The error messages by the test */
    enum CMUnitTestStatus status; /* PASSED, FAILED, ABORT ... */
    double runtime; /* Time calculations */
};

/* Exit the currently executing test. */
static void exit_test(const int quit_application)
{
    const char *abort_test = getenv("CMOCKA_TEST_ABORT");

    if (abort_test != NULL && abort_test[0] == '1') {
        print_error("%s", cm_error_message);
        abort();
    } else if (global_running_test) {
        longjmp(global_run_test_env, 1);
    } else if (quit_application) {
        exit(-1);
    }
}

void _skip(const char * const file, const int line)
{
    cm_print_error(SOURCE_LOCATION_FORMAT ": Skipped!\n", file, line);
    global_skip_test = 1;
    exit_test(1);
}

/* Initialize a SourceLocation structure. */
static void initialize_source_location(SourceLocation * const location) {
    assert_non_null(location);
    location->file = NULL;
    location->line = 0;
}


/* Determine whether a source location is currently set. */
static int source_location_is_set(const SourceLocation * const location) {
    assert_non_null(location);
    return location->file && location->line;
}


/* Set a source location. */
static void set_source_location(
    SourceLocation * const location, const char * const file,
    const int line) {
    assert_non_null(location);
    location->file = file;
    location->line = line;
}


/* Create function results and expected parameter lists. */
void initialize_testing(const char *test_name) {
	(void)test_name;
    list_initialize(&global_function_result_map_head);
    initialize_source_location(&global_last_mock_value_location);
    list_initialize(&global_function_parameter_map_head);
    initialize_source_location(&global_last_parameter_location);
}


static void fail_if_leftover_values(const char *test_name) {
    int error_occurred = 0;
	(void)test_name;
    remove_always_return_values(&global_function_result_map_head, 1);
    if (check_for_leftover_values(
            &global_function_result_map_head,
            "%s() has remaining non-returned values.\n", 1)) {
        error_occurred = 1;
    }

    remove_always_return_values(&global_function_parameter_map_head, 2);
    if (check_for_leftover_values(
            &global_function_parameter_map_head,
            "%s parameter still has values that haven't been checked.\n", 2)) {
        error_occurred = 1;
    }
    if (error_occurred) {
        exit_test(1);
    }
}


static void teardown_testing(const char *test_name) {
	(void)test_name;
    list_free(&global_function_result_map_head, free_symbol_map_value,
              (void*)0);
    initialize_source_location(&global_last_mock_value_location);
    list_free(&global_function_parameter_map_head, free_symbol_map_value,
              (void*)1);
    initialize_source_location(&global_last_parameter_location);
}

/* Initialize a list node. */
static ListNode* list_initialize(ListNode * const node) {
    node->value = NULL;
    node->next = node;
    node->prev = node;
    node->refcount = 1;
    return node;
}


/*
 * Adds a value at the tail of a given list.
 * The node referencing the value is allocated from the heap.
 */
static ListNode* list_add_value(ListNode * const head, const void *value,
                                     const int refcount) {
    ListNode * const new_node = (ListNode*)malloc(sizeof(ListNode));
    assert_non_null(head);
    assert_non_null(value);
    new_node->value = value;
    new_node->refcount = refcount;
    return list_add(head, new_node);
}


/* Add new_node to the end of the list. */
static ListNode* list_add(ListNode * const head, ListNode *new_node) {
    assert_non_null(head);
    assert_non_null(new_node);
    new_node->next = head;
    new_node->prev = head->prev;
    head->prev->next = new_node;
    head->prev = new_node;
    return new_node;
}


/* Remove a node from a list. */
static ListNode* list_remove(
        ListNode * const node, const CleanupListValue cleanup_value,
        void * const cleanup_value_data) {
    assert_non_null(node);
    node->prev->next = node->next;
    node->next->prev = node->prev;
    if (cleanup_value) {
        cleanup_value(node->value, cleanup_value_data);
    }
    return node;
}


/* Remove a list node from a list and free the node. */
static void list_remove_free(
        ListNode * const node, const CleanupListValue cleanup_value,
        void * const cleanup_value_data) {
    assert_non_null(node);
    free(list_remove(node, cleanup_value, cleanup_value_data));
}


/*
 * Frees memory kept by a linked list The cleanup_value function is called for
 * every "value" field of nodes in the list, except for the head.  In addition
 * to each list value, cleanup_value_data is passed to each call to
 * cleanup_value.  The head of the list is not deallocated.
 */
static ListNode* list_free(
        ListNode * const head, const CleanupListValue cleanup_value,
        void * const cleanup_value_data) {
    assert_non_null(head);
    while (!list_empty(head)) {
        list_remove_free(head->next, cleanup_value, cleanup_value_data);
    }
    return head;
}


/* Determine whether a list is empty. */
static int list_empty(const ListNode * const head) {
    assert_non_null(head);
    return head->next == head;
}


/*
 * Find a value in the list using the equal_func to compare each node with the
 * value.
 */
static int list_find(ListNode * const head, const void *value,
                     const EqualityFunction equal_func, ListNode **output) {
    ListNode *current;
    assert_non_null(head);
    for (current = head->next; current != head; current = current->next) {
        if (equal_func(current->value, value)) {
            *output = current;
            return 1;
        }
    }
    return 0;
}

/* Returns the first node of a list */
static int list_first(ListNode * const head, ListNode **output) {
    ListNode *target_node;
    assert_non_null(head);
    if (list_empty(head)) {
        return 0;
    }
    target_node = head->next;
    *output = target_node;
    return 1;
}


/* Deallocate a value referenced by a list. */
static void free_value(const void *value, void *cleanup_value_data) {
	(void)cleanup_value_data;
    assert_non_null(value);
    free((void*)value);
}


/* Releases memory associated to a symbol_map_value. */
static void free_symbol_map_value(const void *value,
                                  void *cleanup_value_data) {
    SymbolMapValue * const map_value = (SymbolMapValue*)value;
    const LargestIntegralType children = cast_ptr_to_largest_integral_type(cleanup_value_data);
    assert_non_null(value);
    list_free(&map_value->symbol_values_list_head,
              children ? free_symbol_map_value : free_value,
              (void *) ((uintptr_t)children - 1));
    free(map_value);
}


/*
 * Determine whether a symbol name referenced by a symbol_map_value matches the
 * specified function name.
 */
static int symbol_names_match(const void *map_value, const void *symbol) {
    return !strcmp(((SymbolMapValue*)map_value)->symbol_name,
                   (const char*)symbol);
}


/*
 * Adds a value to the queue of values associated with the given hierarchy of
 * symbols.  It's assumed value is allocated from the heap.
 */
static void add_symbol_value(ListNode * const symbol_map_head,
                             const char * const symbol_names[],
                             const size_t number_of_symbol_names,
                             const void* value, const int refcount) {
    const char* symbol_name;
    ListNode *target_node;
    SymbolMapValue *target_map_value;
    assert_non_null(symbol_map_head);
    assert_non_null(symbol_names);
    assert_true(number_of_symbol_names);
    symbol_name = symbol_names[0];

    if (!list_find(symbol_map_head, symbol_name, symbol_names_match,
                   &target_node)) {
        SymbolMapValue * const new_symbol_map_value =
            (SymbolMapValue*)malloc(sizeof(*new_symbol_map_value));
        new_symbol_map_value->symbol_name = symbol_name;
        list_initialize(&new_symbol_map_value->symbol_values_list_head);
        target_node = list_add_value(symbol_map_head, new_symbol_map_value,
                                          1);
    }

    target_map_value = (SymbolMapValue*)target_node->value;
    if (number_of_symbol_names == 1) {
            list_add_value(&target_map_value->symbol_values_list_head,
                                value, refcount);
    } else {
        add_symbol_value(&target_map_value->symbol_values_list_head,
                         &symbol_names[1], number_of_symbol_names - 1, value,
                         refcount);
    }
}


/*
 * Gets the next value associated with the given hierarchy of symbols.
 * The value is returned as an output parameter with the function returning the
 * node's old refcount value if a value is found, 0 otherwise.  This means that
 * a return value of 1 indicates the node was just removed from the list.
 */
static int get_symbol_value(
        ListNode * const head, const char * const symbol_names[],
        const size_t number_of_symbol_names, void **output) {
    const char* symbol_name;
    ListNode *target_node;
    assert_non_null(head);
    assert_non_null(symbol_names);
    assert_true(number_of_symbol_names);
    assert_non_null(output);
    symbol_name = symbol_names[0];

    if (list_find(head, symbol_name, symbol_names_match, &target_node)) {
        SymbolMapValue *map_value;
        ListNode *child_list;
        int return_value = 0;
        assert_non_null(target_node);
        assert_non_null(target_node->value);

        map_value = (SymbolMapValue*)target_node->value;
        child_list = &map_value->symbol_values_list_head;

        if (number_of_symbol_names == 1) {
            ListNode *value_node = NULL;
            return_value = list_first(child_list, &value_node);
            assert_true(return_value);
            *output = (void*) value_node->value;
            return_value = value_node->refcount;
            if (--value_node->refcount == 0) {
                list_remove_free(value_node, NULL, NULL);
            }
        } else {
            return_value = get_symbol_value(
                child_list, &symbol_names[1], number_of_symbol_names - 1,
                output);
        }
        if (list_empty(child_list)) {
            list_remove_free(target_node, free_symbol_map_value, (void*)0);
        }
        return return_value;
    } else {
        cm_print_error("No entries for symbol %s.\n", symbol_name);
    }
    return 0;
}


/*
 * Traverse down a tree of symbol values and remove the first symbol value
 * in each branch that has a refcount < -1 (i.e should always be returned
 * and has been returned at least once).
 */
static void remove_always_return_values(ListNode * const map_head,
                                        const size_t number_of_symbol_names) {
    ListNode *current;
    assert_non_null(map_head);
    assert_true(number_of_symbol_names);
    current = map_head->next;
    while (current != map_head) {
        SymbolMapValue * const value = (SymbolMapValue*)current->value;
        ListNode * const next = current->next;
        ListNode *child_list;
        assert_non_null(value);
        child_list = &value->symbol_values_list_head;

        if (!list_empty(child_list)) {
            if (number_of_symbol_names == 1) {
                ListNode * const child_node = child_list->next;
                /* If this item has been returned more than once, free it. */
                if (child_node->refcount < -1) {
                    list_remove_free(child_node, free_value, NULL);
                }
            } else {
                remove_always_return_values(child_list,
                                            number_of_symbol_names - 1);
            }
        }

        if (list_empty(child_list)) {
            list_remove_free(current, free_value, NULL);
        }
        current = next;
    }
}

/*
 * Checks if there are any leftover values set up by the test that were never
 * retrieved through execution, and fail the test if that is the case.
 */
static int check_for_leftover_values(
        const ListNode * const map_head, const char * const error_message,
        const size_t number_of_symbol_names) {
    const ListNode *current;
    int symbols_with_leftover_values = 0;
    assert_non_null(map_head);
    assert_true(number_of_symbol_names);

    for (current = map_head->next; current != map_head;
         current = current->next) {
        const SymbolMapValue * const value =
            (SymbolMapValue*)current->value;
        const ListNode *child_list;
        assert_non_null(value);
        child_list = &value->symbol_values_list_head;

        if (!list_empty(child_list)) {
            if (number_of_symbol_names == 1) {
                const ListNode *child_node;
                cm_print_error(error_message, value->symbol_name);

                for (child_node = child_list->next; child_node != child_list;
                     child_node = child_node->next) {
                    const SourceLocation * const location =
                        (const SourceLocation*)child_node->value;
                    cm_print_error(SOURCE_LOCATION_FORMAT
                                   ": note: remaining item was declared here\n",
                                   location->file, location->line);
                }
            } else {
                cm_print_error("%s.", value->symbol_name);
                check_for_leftover_values(child_list, error_message,
                                          number_of_symbol_names - 1);
            }
            symbols_with_leftover_values ++;
        }
    }
    return symbols_with_leftover_values;
}


/* Get the next return value for the specified mock function. */
LargestIntegralType _mock(const char * const function, const char* const file,
                          const int line) {
    void *result;
    const int rc = get_symbol_value(&global_function_result_map_head,
                                    &function, 1, &result);
    if (rc) {
        SymbolValue * const symbol = (SymbolValue*)result;
        const LargestIntegralType value = symbol->value;
        global_last_mock_value_location = symbol->location;
        if (rc == 1) {
            free(symbol);
        }
        return value;
    } else {
        cm_print_error(SOURCE_LOCATION_FORMAT ": error: Could not get value "
                       "to mock function %s\n", file, line, function);
        if (source_location_is_set(&global_last_mock_value_location)) {
            cm_print_error(SOURCE_LOCATION_FORMAT
                           ": note: Previously returned mock value was declared here\n",
                           global_last_mock_value_location.file,
                           global_last_mock_value_location.line);
        } else {
            cm_print_error("There were no previously returned mock values for "
                           "this test.\n");
        }
        exit_test(1);
    }
    return 0;
}


/* Add a return value for the specified mock function name. */
void _will_return(const char * const function_name, const char * const file,
                  const int line, const LargestIntegralType value,
                  const int count) {
    SymbolValue * const return_value =
	    (SymbolValue*)malloc(sizeof(*return_value));
    assert_true(count > 0 || count == -1);
    return_value->value = value;
    set_source_location(&return_value->location, file, line);
    add_symbol_value(&global_function_result_map_head, &function_name, 1,
                     return_value, count);
}


/*
 * Add a custom parameter checking function.  If the event parameter is NULL
 * the event structure is allocated internally by this function.  If event
 * parameter is provided it must be allocated on the heap and doesn't need to
 * be deallocated by the caller.
 */
void _expect_check(
        const char* const function, const char* const parameter,
        const char* const file, const int line,
        const CheckParameterValue check_function,
        const LargestIntegralType check_data,
        CheckParameterEvent * const event, const int count) {
    CheckParameterEvent * const check =
        event ? event : (CheckParameterEvent*)malloc(sizeof(*check));
    const char* symbols[] = {function, parameter};
    check->parameter_name = parameter;
    check->check_value = check_function;
    check->check_value_data = check_data;
    set_source_location(&check->location, file, line);
    add_symbol_value(&global_function_parameter_map_head, symbols, 2, check,
                     count);
}


/* Returns 1 if the specified values are equal.  If the values are not equal
 * an error is displayed and 0 is returned. */
static int values_equal_display_error(const LargestIntegralType left,
                                      const LargestIntegralType right) {
    const int equal = left == right;
    if (!equal) {
        cm_print_error(LargestIntegralTypePrintfFormat " != "
                       LargestIntegralTypePrintfFormat "\n", left, right);
    }
    return equal;
}

/*
 * Returns 1 if the specified values are not equal.  If the values are equal
 * an error is displayed and 0 is returned. */
static int values_not_equal_display_error(const LargestIntegralType left,
                                          const LargestIntegralType right) {
    const int not_equal = left != right;
    if (!not_equal) {
        cm_print_error(LargestIntegralTypePrintfFormat " == "
                       LargestIntegralTypePrintfFormat "\n", left, right);
    }
    return not_equal;
}


/*
 * Determine whether value is contained within check_integer_set.
 * If invert is 0 and the value is in the set 1 is returned, otherwise 0 is
 * returned and an error is displayed.  If invert is 1 and the value is not
 * in the set 1 is returned, otherwise 0 is returned and an error is
 * displayed.
 */
static int value_in_set_display_error(
        const LargestIntegralType value,
        const CheckIntegerSet * const check_integer_set, const int invert) {
    int succeeded = invert;
    assert_non_null(check_integer_set);
    {
        const LargestIntegralType * const set = check_integer_set->set;
        const size_t size_of_set = check_integer_set->size_of_set;
        size_t i;
        for (i = 0; i < size_of_set; i++) {
            if (set[i] == value) {
                /* If invert = 0 and item is found, succeeded = 1. */
                /* If invert = 1 and item is found, succeeded = 0. */
                succeeded = !succeeded;
                break;
            }
        }
        if (succeeded) {
            return 1;
        }
        cm_print_error("%" PRIu64 " is %sin the set (", value,
                       invert ? "" : "not ");
        for (i = 0; i < size_of_set; i++) {
            cm_print_error("%" PRIu64 ", ", set[i]);
        }
        cm_print_error(")\n");
    }
    return 0;
}


/*
 * Determine whether a value is within the specified range.  If the value is
 * within the specified range 1 is returned.  If the value isn't within the
 * specified range an error is displayed and 0 is returned.
 */
static int integer_in_range_display_error(
        const LargestIntegralType value, const LargestIntegralType range_min,
        const LargestIntegralType range_max) {
    if (value >= range_min && value <= range_max) {
        return 1;
    }
    cm_print_error("%" PRIu64 " is not within the range %" PRIu64 "-%" PRIu64 "\n",
                   value, range_min, range_max);
    return 0;
}


/*
 * Determine whether a value is within the specified range.  If the value
 * is not within the range 1 is returned.  If the value is within the
 * specified range an error is displayed and zero is returned.
 */
static int integer_not_in_range_display_error(
        const LargestIntegralType value, const LargestIntegralType range_min,
        const LargestIntegralType range_max) {
    if (value < range_min || value > range_max) {
        return 1;
    }
    cm_print_error("%" PRIu64 " is within the range %" PRIu64 "-%" PRIu64 "\n",
                   value, range_min, range_max);
    return 0;
}


/*
 * Determine whether the specified strings are equal.  If the strings are equal
 * 1 is returned.  If they're not equal an error is displayed and 0 is
 * returned.
 */
static int string_equal_display_error(
        const char * const left, const char * const right) {
    if (strcmp(left, right) == 0) {
        return 1;
    }
    cm_print_error("\"%s\" != \"%s\"\n", left, right);
    return 0;
}


/*
 * Determine whether the specified strings are equal.  If the strings are not
 * equal 1 is returned.  If they're not equal an error is displayed and 0 is
 * returned
 */
static int string_not_equal_display_error(
        const char * const left, const char * const right) {
    if (strcmp(left, right) != 0) {
        return 1;
    }
    cm_print_error("\"%s\" == \"%s\"\n", left, right);
    return 0;
}


/*
 * Determine whether the specified areas of memory are equal.  If they're equal
 * 1 is returned otherwise an error is displayed and 0 is returned.
 */
static int memory_equal_display_error(const char* const a, const char* const b,
                                      const size_t size) {
    int differences = 0;
    size_t i;
    for (i = 0; i < size; i++) {
        const char l = a[i];
        const char r = b[i];
        if (l != r) {
            cm_print_error("difference at offset %" PRIdS " 0x%02x 0x%02x\n",
                           i, l, r);
            differences ++;
        }
    }
    if (differences) {
        cm_print_error("%d bytes of %p and %p differ\n", differences,
                    a, b);
        return 0;
    }
    return 1;
}


/*
 * Determine whether the specified areas of memory are not equal.  If they're
 * not equal 1 is returned otherwise an error is displayed and 0 is
 * returned.
 */
static int memory_not_equal_display_error(
        const char* const a, const char* const b, const size_t size) {
    size_t same = 0;
    size_t i;
    for (i = 0; i < size; i++) {
        const char l = a[i];
        const char r = b[i];
        if (l == r) {
            same ++;
        }
    }
    if (same == size) {
        cm_print_error("%"PRIdS "bytes of %p and %p the same\n", same,
                    a, b);
        return 0;
    }
    return 1;
}


/* CheckParameterValue callback to check whether a value is within a set. */
static int check_in_set(const LargestIntegralType value,
                        const LargestIntegralType check_value_data) {
    return value_in_set_display_error(value,
        cast_largest_integral_type_to_pointer(CheckIntegerSet*,
                                              check_value_data), 0);
}


/* CheckParameterValue callback to check whether a value isn't within a set. */
static int check_not_in_set(const LargestIntegralType value,
                            const LargestIntegralType check_value_data) {
    return value_in_set_display_error(value,
        cast_largest_integral_type_to_pointer(CheckIntegerSet*,
                                              check_value_data), 1);
}


/* Create the callback data for check_in_set() or check_not_in_set() and
 * register a check event. */
static void expect_set(
        const char* const function, const char* const parameter,
        const char* const file, const int line,
        const LargestIntegralType values[], const size_t number_of_values,
        const CheckParameterValue check_function, const int count) {
    CheckIntegerSet * const check_integer_set =
        (CheckIntegerSet*)malloc(sizeof(*check_integer_set) +
               (sizeof(values[0]) * number_of_values));
    LargestIntegralType * const set = (LargestIntegralType*)(
        check_integer_set + 1);
    declare_initialize_value_pointer_pointer(check_data, check_integer_set);
    assert_non_null(values);
    assert_true(number_of_values);
    memcpy(set, values, number_of_values * sizeof(values[0]));
    check_integer_set->set = set;
    check_integer_set->size_of_set = number_of_values;
    _expect_check(
        function, parameter, file, line, check_function,
        check_data.value, &check_integer_set->event, count);
}


/* Add an event to check whether a value is in a set. */
void _expect_in_set(
        const char* const function, const char* const parameter,
        const char* const file, const int line,
        const LargestIntegralType values[], const size_t number_of_values,
        const int count) {
    expect_set(function, parameter, file, line, values, number_of_values,
               check_in_set, count);
}


/* Add an event to check whether a value isn't in a set. */
void _expect_not_in_set(
        const char* const function, const char* const parameter,
        const char* const file, const int line,
        const LargestIntegralType values[], const size_t number_of_values,
        const int count) {
    expect_set(function, parameter, file, line, values, number_of_values,
               check_not_in_set, count);
}


/* CheckParameterValue callback to check whether a value is within a range. */
static int check_in_range(const LargestIntegralType value,
                          const LargestIntegralType check_value_data) {
    CheckIntegerRange * const check_integer_range =
        cast_largest_integral_type_to_pointer(CheckIntegerRange*,
                                              check_value_data);
    assert_non_null(check_integer_range);
    return integer_in_range_display_error(value, check_integer_range->minimum,
                                          check_integer_range->maximum);
}


/* CheckParameterValue callback to check whether a value is not within a range. */
static int check_not_in_range(const LargestIntegralType value,
                              const LargestIntegralType check_value_data) {
    CheckIntegerRange * const check_integer_range =
        cast_largest_integral_type_to_pointer(CheckIntegerRange*,
                                              check_value_data);
    assert_non_null(check_integer_range);
    return integer_not_in_range_display_error(
        value, check_integer_range->minimum, check_integer_range->maximum);
}


/* Create the callback data for check_in_range() or check_not_in_range() and
 * register a check event. */
static void expect_range(
        const char* const function, const char* const parameter,
        const char* const file, const int line,
        const LargestIntegralType minimum, const LargestIntegralType maximum,
        const CheckParameterValue check_function, const int count) {
    CheckIntegerRange * const check_integer_range =
        (CheckIntegerRange*)malloc(sizeof(*check_integer_range));
    declare_initialize_value_pointer_pointer(check_data, check_integer_range);
    check_integer_range->minimum = minimum;
    check_integer_range->maximum = maximum;
    _expect_check(function, parameter, file, line, check_function,
                  check_data.value, &check_integer_range->event, count);
}


/* Add an event to determine whether a parameter is within a range. */
void _expect_in_range(
        const char* const function, const char* const parameter,
        const char* const file, const int line,
        const LargestIntegralType minimum, const LargestIntegralType maximum,
        const int count) {
    expect_range(function, parameter, file, line, minimum, maximum,
                 check_in_range, count);
}


/* Add an event to determine whether a parameter is not within a range. */
void _expect_not_in_range(
        const char* const function, const char* const parameter,
        const char* const file, const int line,
        const LargestIntegralType minimum, const LargestIntegralType maximum,
        const int count) {
    expect_range(function, parameter, file, line, minimum, maximum,
                 check_not_in_range, count);
}


/* CheckParameterValue callback to check whether a value is equal to an
 * expected value. */
static int check_value(const LargestIntegralType value,
                       const LargestIntegralType check_value_data) {
    return values_equal_display_error(value, check_value_data);
}


/* Add an event to check a parameter equals an expected value. */
void _expect_value(
        const char* const function, const char* const parameter,
        const char* const file, const int line,
        const LargestIntegralType value, const int count) {
    _expect_check(function, parameter, file, line, check_value, value, NULL,
                  count);
}


/* CheckParameterValue callback to check whether a value is not equal to an
 * expected value. */
static int check_not_value(const LargestIntegralType value,
                           const LargestIntegralType check_value_data) {
    return values_not_equal_display_error(value, check_value_data);
}


/* Add an event to check a parameter is not equal to an expected value. */
void _expect_not_value(
        const char* const function, const char* const parameter,
        const char* const file, const int line,
        const LargestIntegralType value, const int count) {
    _expect_check(function, parameter, file, line, check_not_value, value,
                  NULL, count);
}


/* CheckParameterValue callback to check whether a parameter equals a string. */
static int check_string(const LargestIntegralType value,
                        const LargestIntegralType check_value_data) {
    return string_equal_display_error(
        cast_largest_integral_type_to_pointer(char*, value),
        cast_largest_integral_type_to_pointer(char*, check_value_data));
}


/* Add an event to check whether a parameter is equal to a string. */
void _expect_string(
        const char* const function, const char* const parameter,
        const char* const file, const int line, const char* string,
        const int count) {
    declare_initialize_value_pointer_pointer(string_pointer,
                                             discard_const(string));
    _expect_check(function, parameter, file, line, check_string,
                  string_pointer.value, NULL, count);
}


/* CheckParameterValue callback to check whether a parameter is not equals to
 * a string. */
static int check_not_string(const LargestIntegralType value,
                            const LargestIntegralType check_value_data) {
    return string_not_equal_display_error(
        cast_largest_integral_type_to_pointer(char*, value),
        cast_largest_integral_type_to_pointer(char*, check_value_data));
}


/* Add an event to check whether a parameter is not equal to a string. */
void _expect_not_string(
        const char* const function, const char* const parameter,
        const char* const file, const int line, const char* string,
        const int count) {
    declare_initialize_value_pointer_pointer(string_pointer,
                                             discard_const(string));
    _expect_check(function, parameter, file, line, check_not_string,
                  string_pointer.value, NULL, count);
}

/* CheckParameterValue callback to check whether a parameter equals an area of
 * memory. */
static int check_memory(const LargestIntegralType value,
                        const LargestIntegralType check_value_data) {
    CheckMemoryData * const check = cast_largest_integral_type_to_pointer(
        CheckMemoryData*, check_value_data);
    assert_non_null(check);
    return memory_equal_display_error(
        cast_largest_integral_type_to_pointer(const char*, value),
        (const char*)check->memory, check->size);
}


/* Create the callback data for check_memory() or check_not_memory() and
 * register a check event. */
static void expect_memory_setup(
        const char* const function, const char* const parameter,
        const char* const file, const int line,
        const void * const memory, const size_t size,
        const CheckParameterValue check_function, const int count) {
    CheckMemoryData * const check_data =
	    (CheckMemoryData*)malloc(sizeof(*check_data) + size);
    void * const mem = (void*)(check_data + 1);
    declare_initialize_value_pointer_pointer(check_data_pointer, check_data);
    assert_non_null(memory);
    assert_true(size);
    memcpy(mem, memory, size);
    check_data->memory = mem;
    check_data->size = size;
    _expect_check(function, parameter, file, line, check_function,
                  check_data_pointer.value, &check_data->event, count);
}


/* Add an event to check whether a parameter matches an area of memory. */
void _expect_memory(
        const char* const function, const char* const parameter,
        const char* const file, const int line, const void* const memory,
        const size_t size, const int count) {
    expect_memory_setup(function, parameter, file, line, memory, size,
                        check_memory, count);
}


/* CheckParameterValue callback to check whether a parameter is not equal to
 * an area of memory. */
static int check_not_memory(const LargestIntegralType value,
                            const LargestIntegralType check_value_data) {
    CheckMemoryData * const check = cast_largest_integral_type_to_pointer(
        CheckMemoryData*, check_value_data);
    assert_non_null(check);
    return memory_not_equal_display_error(
        cast_largest_integral_type_to_pointer(const char*, value),
	(const char*)check->memory,
        check->size);
}


/* Add an event to check whether a parameter doesn't match an area of memory. */
void _expect_not_memory(
        const char* const function, const char* const parameter,
        const char* const file, const int line, const void* const memory,
        const size_t size, const int count) {
    expect_memory_setup(function, parameter, file, line, memory, size,
                        check_not_memory, count);
}


/* CheckParameterValue callback that always returns 1. */
static int check_any(const LargestIntegralType value,
                     const LargestIntegralType check_value_data) {
	(void)value;
	(void)check_value_data;
    return 1;
}


/* Add an event to allow any value for a parameter. */
void _expect_any(
        const char* const function, const char* const parameter,
        const char* const file, const int line, const int count) {
    _expect_check(function, parameter, file, line, check_any, 0, NULL,
                  count);
}


void _check_expected(
        const char * const function_name, const char * const parameter_name,
        const char* file, const int line, const LargestIntegralType value) {
    void *result;
    const char* symbols[] = {function_name, parameter_name};
    const int rc = get_symbol_value(&global_function_parameter_map_head,
                                    symbols, 2, &result);
    if (rc) {
        CheckParameterEvent * const check = (CheckParameterEvent*)result;
        int check_succeeded;
        global_last_parameter_location = check->location;
        check_succeeded = check->check_value(value, check->check_value_data);
        if (rc == 1) {
            free(check);
        }
        if (!check_succeeded) {
            cm_print_error(SOURCE_LOCATION_FORMAT
                           ": error: Check of parameter %s, function %s failed\n"
                           SOURCE_LOCATION_FORMAT
                           ": note: Expected parameter declared here\n",
                           file, line,
                           parameter_name, function_name,
                           global_last_parameter_location.file,
                           global_last_parameter_location.line);
            _fail(file, line);
        }
    } else {
        cm_print_error(SOURCE_LOCATION_FORMAT ": error: Could not get value "
                    "to check parameter %s of function %s\n", file, line,
                    parameter_name, function_name);
        if (source_location_is_set(&global_last_parameter_location)) {
            cm_print_error(SOURCE_LOCATION_FORMAT
                        ": note: Previously declared parameter value was declared here\n",
                        global_last_parameter_location.file,
                        global_last_parameter_location.line);
        } else {
            cm_print_error("There were no previously declared parameter values "
                        "for this test.\n");
        }
        exit_test(1);
    }
}


/* Replacement for assert. */
void mock_assert(const int result, const char* const expression,
                 const char* const file, const int line) {
    if (!result) {
        if (global_expecting_assert) {
            global_last_failed_assert = expression;
            longjmp(global_expect_assert_env, result);
        } else {
            cm_print_error("ASSERT: %s\n", expression);
            _fail(file, line);
        }
    }
}


void _assert_true(const LargestIntegralType result,
                  const char * const expression,
                  const char * const file, const int line) {
    if (!result) {
        cm_print_error("%s\n", expression);
        _fail(file, line);
    }
}

void _assert_return_code(const LargestIntegralType result,
                         size_t rlen,
                         const LargestIntegralType error,
                         const char * const expression,
                         const char * const file,
                         const int line)
{
    LargestIntegralType valmax;


    switch (rlen) {
    case 1:
        valmax = 255;
        break;
    case 2:
        valmax = 32767;
        break;
    case 4:
        valmax = 2147483647;
        break;
    case 8:
    default:
        if (rlen > sizeof(valmax)) {
            valmax = 2147483647;
        } else {
            valmax = 9223372036854775807L;
        }
        break;
    }

    if (result > valmax - 1) {
        if (error > 0) {
            cm_print_error("%s < 0, errno(%" PRIu64 "): %s\n",
                           expression, error, strerror((int)error));
        } else {
            cm_print_error("%s < 0\n", expression);
        }
        _fail(file, line);
    }
}

void _assert_int_equal(
        const LargestIntegralType a, const LargestIntegralType b,
        const char * const file, const int line) {
    if (!values_equal_display_error(a, b)) {
        _fail(file, line);
    }
}


void _assert_int_not_equal(
        const LargestIntegralType a, const LargestIntegralType b,
        const char * const file, const int line) {
    if (!values_not_equal_display_error(a, b)) {
        _fail(file, line);
    }
}


void _assert_string_equal(const char * const a, const char * const b,
                          const char * const file, const int line) {
    if (!string_equal_display_error(a, b)) {
        _fail(file, line);
    }
}


void _assert_string_not_equal(const char * const a, const char * const b,
                              const char *file, const int line) {
    if (!string_not_equal_display_error(a, b)) {
        _fail(file, line);
    }
}


void _assert_memory_equal(const void * const a, const void * const b,
                          const size_t size, const char* const file,
                          const int line) {
    if (!memory_equal_display_error((const char*)a, (const char*)b, size)) {
        _fail(file, line);
    }
}


void _assert_memory_not_equal(const void * const a, const void * const b,
                              const size_t size, const char* const file,
                              const int line) {
    if (!memory_not_equal_display_error((const char*)a, (const char*)b,
                                        size)) {
        _fail(file, line);
    }
}


void _assert_in_range(
        const LargestIntegralType value, const LargestIntegralType minimum,
        const LargestIntegralType maximum, const char* const file,
        const int line) {
    if (!integer_in_range_display_error(value, minimum, maximum)) {
        _fail(file, line);
    }
}

void _assert_not_in_range(
        const LargestIntegralType value, const LargestIntegralType minimum,
        const LargestIntegralType maximum, const char* const file,
        const int line) {
    if (!integer_not_in_range_display_error(value, minimum, maximum)) {
        _fail(file, line);
    }
}

void _assert_in_set(const LargestIntegralType value,
                    const LargestIntegralType values[],
                    const size_t number_of_values, const char* const file,
                    const int line) {
    CheckIntegerSet check_integer_set;
    check_integer_set.set = values;
    check_integer_set.size_of_set = number_of_values;
    if (!value_in_set_display_error(value, &check_integer_set, 0)) {
        _fail(file, line);
    }
}

void _assert_not_in_set(const LargestIntegralType value,
                        const LargestIntegralType values[],
                        const size_t number_of_values, const char* const file,
                        const int line) {
    CheckIntegerSet check_integer_set;
    check_integer_set.set = values;
    check_integer_set.size_of_set = number_of_values;
    if (!value_in_set_display_error(value, &check_integer_set, 1)) {
        _fail(file, line);
    }
}


/* Get the list of allocated blocks. */
static ListNode* get_allocated_blocks_list() {
    /* If it initialized, initialize the list of allocated blocks. */
    if (!global_allocated_blocks.value) {
        list_initialize(&global_allocated_blocks);
        global_allocated_blocks.value = (void*)1;
    }
    return &global_allocated_blocks;
}

static void *libc_malloc(size_t size)
{
#undef malloc
    return malloc(size);
#define malloc test_malloc
}

static void libc_free(void *ptr)
{
#undef free
    free(ptr);
#define free test_free
}

static void *libc_realloc(void *ptr, size_t size)
{
#undef realloc
    return realloc(ptr, size);
#define realloc test_realloc
}

static void vcm_print_error(const char* const format,
                            va_list args) CMOCKA_PRINTF_ATTRIBUTE(1, 0);

/* It's important to use the libc malloc and free here otherwise
 * the automatic free of leaked blocks can reap the error messages
 */
static void vcm_print_error(const char* const format, va_list args)
{
    char buffer[1024];
    size_t msg_len = 0;
    va_list ap;
    int len;

    len = vsnprintf(buffer, sizeof(buffer), format, args);
    if (len < 0) {
        /* TODO */
        return;
    }

    if (cm_error_message == NULL) {
        /* CREATE MESSAGE */

        cm_error_message = libc_malloc(len + 1);
        if (cm_error_message == NULL) {
            /* TODO */
            return;
        }
    } else {
        /* APPEND MESSAGE */
        char *tmp;

        msg_len = strlen(cm_error_message);
        tmp = libc_realloc(cm_error_message, msg_len + len + 1);
        if (tmp == NULL) {
            return;
        }
        cm_error_message = tmp;
    }

    if (((size_t)len) < sizeof(buffer)) {
        /* Use len + 1 to also copy '\0' */
        memcpy(cm_error_message + msg_len, buffer, len + 1);
    } else {
        va_copy(ap, args);
        vsnprintf(cm_error_message + msg_len, len, format, ap);
        va_end(ap);
    }
}

static void vcm_free_error(char *err_msg)
{
    libc_free(err_msg);
}

/* Use the real malloc in this function. */
#undef malloc
void* _test_malloc(const size_t size, const char* file, const int line) {
    char* ptr;
    MallocBlockInfo *block_info;
    ListNode * const block_list = get_allocated_blocks_list();
    const size_t allocate_size = size + (MALLOC_GUARD_SIZE * 2) +
        sizeof(*block_info) + MALLOC_ALIGNMENT;
    char* const block = (char*)malloc(allocate_size);
    assert_non_null(block);

    /* Calculate the returned address. */
    ptr = (char*)(((size_t)block + MALLOC_GUARD_SIZE + sizeof(*block_info) +
                  MALLOC_ALIGNMENT) & ~(MALLOC_ALIGNMENT - 1));

    /* Initialize the guard blocks. */
    memset(ptr - MALLOC_GUARD_SIZE, MALLOC_GUARD_PATTERN, MALLOC_GUARD_SIZE);
    memset(ptr + size, MALLOC_GUARD_PATTERN, MALLOC_GUARD_SIZE);
    memset(ptr, MALLOC_ALLOC_PATTERN, size);

    block_info = (MallocBlockInfo*)(ptr - (MALLOC_GUARD_SIZE +
                                             sizeof(*block_info)));
    set_source_location(&block_info->location, file, line);
    block_info->allocated_size = allocate_size;
    block_info->size = size;
    block_info->block = block;
    block_info->node.value = block_info;
    list_add(block_list, &block_info->node);
    return ptr;
}
#define malloc test_malloc


void* _test_calloc(const size_t number_of_elements, const size_t size,
                   const char* file, const int line) {
    void* const ptr = _test_malloc(number_of_elements * size, file, line);
    if (ptr) {
        memset(ptr, 0, number_of_elements * size);
    }
    return ptr;
}


/* Use the real free in this function. */
#undef free
void _test_free(void* const ptr, const char* file, const int line) {
    unsigned int i;
    char *block = discard_const_p(char, ptr);
    MallocBlockInfo *block_info;

    if (ptr == NULL) {
        return;
    }

    _assert_true(cast_ptr_to_largest_integral_type(ptr), "ptr", file, line);
    block_info = (MallocBlockInfo*)(block - (MALLOC_GUARD_SIZE +
                                               sizeof(*block_info)));
    /* Check the guard blocks. */
    {
        char *guards[2] = {block - MALLOC_GUARD_SIZE,
                           block + block_info->size};
        for (i = 0; i < ARRAY_SIZE(guards); i++) {
            unsigned int j;
            char * const guard = guards[i];
            for (j = 0; j < MALLOC_GUARD_SIZE; j++) {
                const char diff = guard[j] - MALLOC_GUARD_PATTERN;
                if (diff) {
                    cm_print_error(SOURCE_LOCATION_FORMAT
                                   ": error: Guard block of %p size=%lu is corrupt\n"
                                   SOURCE_LOCATION_FORMAT ": note: allocated here at %p\n",
                                   file, line,
                                   ptr, (unsigned long)block_info->size,
                                   block_info->location.file, block_info->location.line,
                                   &guard[j]);
                    _fail(file, line);
                }
            }
        }
    }
    list_remove(&block_info->node, NULL, NULL);

    block = discard_const_p(char, block_info->block);
    memset(block, MALLOC_FREE_PATTERN, block_info->allocated_size);
    free(block);
}
#define free test_free

#undef realloc
void *_test_realloc(void *ptr,
                   const size_t size,
                   const char *file,
                   const int line)
{
    MallocBlockInfo *block_info;
    char *block = ptr;
    size_t block_size = size;
    void *new;

    if (ptr == NULL) {
        return _test_malloc(size, file, line);
    }

    if (size == 0) {
        return NULL;
    }

    block_info = (MallocBlockInfo*)(block - (MALLOC_GUARD_SIZE +
                                             sizeof(*block_info)));

    new = _test_malloc(size, file, line);
    if (new == NULL) {
        return NULL;
    }

    if (block_info->size < size) {
        block_size = block_info->size;
    }

    memcpy(new, ptr, block_size);

    /* Free previous memory */
    _test_free(ptr, file, line);

    return new;
}
#define realloc test_realloc

/* Crudely checkpoint the current heap state. */
static const ListNode* check_point_allocated_blocks() {
    return get_allocated_blocks_list()->prev;
}


/* Display the blocks allocated after the specified check point.  This
 * function returns the number of blocks displayed. */
static int display_allocated_blocks(const ListNode * const check_point) {
    const ListNode * const head = get_allocated_blocks_list();
    const ListNode *node;
    int allocated_blocks = 0;
    assert_non_null(check_point);
    assert_non_null(check_point->next);

    for (node = check_point->next; node != head; node = node->next) {
        const MallocBlockInfo * const block_info =
		(const MallocBlockInfo*)node->value;
        assert_non_null(block_info);

        if (!allocated_blocks) {
            cm_print_error("Blocks allocated...\n");
        }
        cm_print_error(SOURCE_LOCATION_FORMAT ": note: block %p allocated here\n",
                       block_info->location.file,
                       block_info->location.line,
                       block_info->block);
        allocated_blocks ++;
    }
    return allocated_blocks;
}


/* Free all blocks allocated after the specified check point. */
static void free_allocated_blocks(const ListNode * const check_point) {
    const ListNode * const head = get_allocated_blocks_list();
    const ListNode *node;
    assert_non_null(check_point);

    node = check_point->next;
    assert_non_null(node);

    while (node != head) {
        MallocBlockInfo * const block_info = (MallocBlockInfo*)node->value;
        node = node->next;
        free(discard_const_p(char, block_info) + sizeof(*block_info) + MALLOC_GUARD_SIZE);
    }
}


/* Fail if any any blocks are allocated after the specified check point. */
static void fail_if_blocks_allocated(const ListNode * const check_point,
                                     const char * const test_name) {
    const int allocated_blocks = display_allocated_blocks(check_point);
    if (allocated_blocks) {
        free_allocated_blocks(check_point);
        cm_print_error("ERROR: %s leaked %d block(s)\n", test_name,
                       allocated_blocks);
        exit_test(1);
    }
}


void _fail(const char * const file, const int line) {
    cm_print_error(SOURCE_LOCATION_FORMAT ": error: Failure!\n", file, line);
    exit_test(1);
}


#ifndef _WIN32
static void exception_handler(int sig) {
#ifdef HAVE_STRSIGNAL
    cm_print_error("Test failed with exception: %s\n", strsignal(sig));
#else
    cm_print_error("Test failed with exception: %d\n", sig);
#endif
    exit_test(1);
}

#else /* _WIN32 */

static LONG WINAPI exception_filter(EXCEPTION_POINTERS *exception_pointers) {
    EXCEPTION_RECORD * const exception_record =
        exception_pointers->ExceptionRecord;
    const DWORD code = exception_record->ExceptionCode;
    unsigned int i;
    for (i = 0; i < ARRAY_SIZE(exception_codes); i++) {
        const ExceptionCodeInfo * const code_info = &exception_codes[i];
        if (code == code_info->code) {
            static int shown_debug_message = 0;
            fflush(stdout);
            cm_print_error("%s occurred at %p.\n", code_info->description,
                        exception_record->ExceptionAddress);
            if (!shown_debug_message) {
                cm_print_error(
                    "\n"
                    "To debug in Visual Studio...\n"
                    "1. Select menu item File->Open Project\n"
                    "2. Change 'Files of type' to 'Executable Files'\n"
                    "3. Open this executable.\n"
                    "4. Select menu item Debug->Start\n"
                    "\n"
                    "Alternatively, set the environment variable \n"
                    "UNIT_TESTING_DEBUG to 1 and rebuild this executable, \n"
                    "then click 'Debug' in the popup dialog box.\n"
                    "\n");
                shown_debug_message = 1;
            }
            exit_test(0);
            return EXCEPTION_EXECUTE_HANDLER;
        }
    }
    return EXCEPTION_CONTINUE_SEARCH;
}
#endif /* !_WIN32 */

void cm_print_error(const char * const format, ...)
{
    va_list args;
    va_start(args, format);
    if (cm_error_message_enabled) {
        vcm_print_error(format, args);
    } else {
        vprint_error(format, args);
    }
    va_end(args);
}

/* Standard output and error print methods. */
void vprint_message(const char* const format, va_list args) {
    char buffer[1024];
    vsnprintf(buffer, sizeof(buffer), format, args);
    printf("%s", buffer);
    fflush(stdout);
#ifdef _WIN32
    OutputDebugString(buffer);
#endif /* _WIN32 */
}


void vprint_error(const char* const format, va_list args) {
    char buffer[1024];
    vsnprintf(buffer, sizeof(buffer), format, args);
    fprintf(stderr, "%s", buffer);
    fflush(stderr);
#ifdef _WIN32
    OutputDebugString(buffer);
#endif /* _WIN32 */
}


void print_message(const char* const format, ...) {
    va_list args;
    va_start(args, format);
    vprint_message(format, args);
    va_end(args);
}


void print_error(const char* const format, ...) {
    va_list args;
    va_start(args, format);
    vprint_error(format, args);
    va_end(args);
}

/* New formatter */
static enum cm_message_output cm_get_output(void)
{
    enum cm_message_output output = global_msg_output;
    char *env;

    env = getenv("CMOCKA_MESSAGE_OUTPUT");
    if (env != NULL) {
        if (strcasecmp(env, "STDOUT") == 0) {
            output = CM_OUTPUT_STDOUT;
        } else if (strcasecmp(env, "SUBUNIT") == 0) {
            output = CM_OUTPUT_SUBUNIT;
        } else if (strcasecmp(env, "TAP") == 0) {
            output = CM_OUTPUT_TAP;
        } else if (strcasecmp(env, "XML") == 0) {
            output = CM_OUTPUT_XML;
        }
    }

    return output;
}

enum cm_printf_type {
    PRINTF_TEST_START,
    PRINTF_TEST_SUCCESS,
    PRINTF_TEST_FAILURE,
    PRINTF_TEST_ERROR,
    PRINTF_TEST_SKIPPED,
};

static void cmprintf_group_finish_xml(const char *group_name,
                                      size_t total_executed,
                                      size_t total_failed,
                                      size_t total_errors,
                                      size_t total_skipped,
                                      double total_runtime,
                                      struct CMUnitTestState *cm_tests)
{
    FILE *fp = stdout;
    int file_opened = 0;
    char *env;
    size_t i;

    env = getenv("CMOCKA_XML_FILE");
    if (env != NULL) {
        char buf[1024];
        snprintf(buf, sizeof(buf), "%s", env);

        fp = fopen(buf, "r");
        if (fp == NULL) {
            fp = fopen(buf, "w");
            if (fp != NULL) {
                file_opened = 1;
            } else {
                fp = stderr;
            }
        } else {
            fclose(fp);
            fp = stderr;
        }
    }

    fprintf(fp, "<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n");
    fprintf(fp, "<testsuites>\n");
    fprintf(fp, "  <testsuite name=\"%s\" time=\"%.3f\" "
                "tests=\"%u\" failures=\"%u\" errors=\"%u\" skipped=\"%u\" >\n",
                group_name,
                total_runtime * 1000, /* miliseconds */
                (unsigned)total_executed,
                (unsigned)total_failed,
                (unsigned)total_errors,
                (unsigned)total_skipped);

    for (i = 0; i < total_executed; i++) {
        struct CMUnitTestState *cmtest = &cm_tests[i];

        fprintf(fp, "    <testcase name=\"%s\" time=\"%.3f\" >\n",
                cmtest->test->name, cmtest->runtime * 1000);

        switch (cmtest->status) {
        case CM_TEST_ERROR:
        case CM_TEST_FAILED:
            if (cmtest->error_message != NULL) {
                fprintf(fp, "      <failure><![CDATA[%s]]></failure>\n",
                        cmtest->error_message);
            } else {
                fprintf(fp, "      <failure message=\"Unknown error\" />\n");
            }
            break;
        case CM_TEST_SKIPPED:
            fprintf(fp, "      <skipped/>\n");
            break;

        case CM_TEST_PASSED:
        case CM_TEST_NOT_STARTED:
            break;
        }

        fprintf(fp, "    </testcase>\n");
    }

    fprintf(fp, "  </testsuite>\n");
    fprintf(fp, "</testsuites>\n");

    if (file_opened) {
        fclose(fp);
    }
}

static void cmprintf_group_start_standard(const size_t num_tests)
{
    print_message("[==========] Running %u test(s).\n",
                  (unsigned)num_tests);
}

static void cmprintf_group_finish_standard(size_t total_executed,
                                           size_t total_passed,
                                           size_t total_failed,
                                           size_t total_errors,
                                           struct CMUnitTestState *cm_tests)
{
    size_t i;

    print_message("[==========] %u test(s) run.\n", (unsigned)total_executed);
    print_error("[  PASSED  ] %u test(s).\n",
                (unsigned)(total_passed));

    if (total_failed) {
        print_error("[  FAILED  ] %"PRIdS " test(s), listed below:\n", total_failed);
        for (i = 0; i < total_executed; i++) {
            struct CMUnitTestState *cmtest = &cm_tests[i];

            if (cmtest->status == CM_TEST_FAILED) {
                print_error("[  FAILED  ] %s\n", cmtest->test->name);
            }
        }
        print_error("\n %u FAILED TEST(S)\n",
                    (unsigned)(total_failed + total_errors));
    }
}

static void cmprintf_standard(enum cm_printf_type type,
                              const char *test_name,
                              const char *error_message)
{
    switch (type) {
    case PRINTF_TEST_START:
        print_message("[ RUN      ] %s\n", test_name);
        break;
    case PRINTF_TEST_SUCCESS:
        print_message("[       OK ] %s\n", test_name);
        break;
    case PRINTF_TEST_FAILURE:
        if (error_message != NULL) {
            print_error("%s\n", error_message);
        }
        print_message("[  FAILED  ] %s\n", test_name);
        break;
    case PRINTF_TEST_SKIPPED:
        print_message("[  SKIPPED ] %s\n", test_name);
        break;
    case PRINTF_TEST_ERROR:
        if (error_message != NULL) {
            print_error("%s\n", error_message);
        }
        print_error("[  ERROR   ] %s\n", test_name);
        break;
    }
}

static void cmprintf_group_start_tap(const size_t num_tests)
{
    print_message("1..%u\n", (unsigned)num_tests);
}

static void cmprintf_tap(enum cm_printf_type type,
                         uint32_t test_number,
                         const char *test_name,
                         const char *error_message)
{
    switch (type) {
    case PRINTF_TEST_START:
        break;
    case PRINTF_TEST_SUCCESS:
        print_message("ok %u - %s\n", (unsigned)test_number, test_name);
        break;
    case PRINTF_TEST_FAILURE:
        print_message("not ok %u - %s\n", (unsigned)test_number, test_name);
        if (error_message != NULL) {
            char *msg;
            char *p;

            msg = strdup(error_message);
            if (msg == NULL) {
                return;
            }
            p = msg;

            while (p[0] != '\0') {
                char *q = p;

                p = strchr(q, '\n');
                if (p != NULL) {
                    p[0] = '\0';
                }

                print_message("# %s\n", q);

                if (p == NULL) {
                    break;
                }
                p++;
            }
            libc_free(msg);
        }
        break;
    case PRINTF_TEST_SKIPPED:
        print_message("not ok %u # SKIP %s\n", (unsigned)test_number, test_name);
        break;
    case PRINTF_TEST_ERROR:
        print_message("not ok %u - %s %s\n",
                      (unsigned)test_number, test_name, error_message);
        break;
    }
}

static void cmprintf_subunit(enum cm_printf_type type,
                             const char *test_name,
                             const char *error_message)
{
    switch (type) {
    case PRINTF_TEST_START:
        print_message("test: %s\n", test_name);
        break;
    case PRINTF_TEST_SUCCESS:
        print_message("success: %s\n", test_name);
        break;
    case PRINTF_TEST_FAILURE:
        print_message("failure: %s", test_name);
        if (error_message != NULL) {
            print_message(" [\n%s]\n", error_message);
        }
        break;
    case PRINTF_TEST_SKIPPED:
        print_message("skip: %s\n", test_name);
        break;
    case PRINTF_TEST_ERROR:
        print_message("error: %s [ %s ]\n", test_name, error_message);
        break;
    }
}

static void cmprintf_group_start(const size_t num_tests)
{
    enum cm_message_output output;

    output = cm_get_output();

    switch (output) {
    case CM_OUTPUT_STDOUT:
        cmprintf_group_start_standard(num_tests);
        break;
    case CM_OUTPUT_SUBUNIT:
        break;
    case CM_OUTPUT_TAP:
        cmprintf_group_start_tap(num_tests);
        break;
    case CM_OUTPUT_XML:
        break;
    }
}

static void cmprintf_group_finish(const char *group_name,
                                  size_t total_executed,
                                  size_t total_passed,
                                  size_t total_failed,
                                  size_t total_errors,
                                  size_t total_skipped,
                                  double total_runtime,
                                  struct CMUnitTestState *cm_tests)
{
    enum cm_message_output output;

    output = cm_get_output();

    switch (output) {
    case CM_OUTPUT_STDOUT:
        cmprintf_group_finish_standard(total_executed,
                                    total_passed,
                                    total_failed,
                                    total_errors,
                                    cm_tests);
        break;
    case CM_OUTPUT_SUBUNIT:
    case CM_OUTPUT_TAP:
        break;
    case CM_OUTPUT_XML:
        cmprintf_group_finish_xml(group_name,
                                  total_executed,
                                  total_failed,
                                  total_errors,
                                  total_skipped,
                                  total_runtime,
                                  cm_tests);
        break;
    }
}

static void cmprintf(enum cm_printf_type type,
                     size_t test_number,
                     const char *test_name,
                     const char *error_message)
{
    enum cm_message_output output;

    output = cm_get_output();

    switch (output) {
    case CM_OUTPUT_STDOUT:
        cmprintf_standard(type, test_name, error_message);
        break;
    case CM_OUTPUT_SUBUNIT:
        cmprintf_subunit(type, test_name, error_message);
        break;
    case CM_OUTPUT_TAP:
        cmprintf_tap(type, test_number, test_name, error_message);
        break;
    case CM_OUTPUT_XML:
        break;
    }
}

void cmocka_set_message_output(enum cm_message_output output)
{
    global_msg_output = output;
}

/****************************************************************************
 * TIME CALCULATIONS
 ****************************************************************************/

#ifdef HAVE_STRUCT_TIMESPEC
static struct timespec cm_tspecdiff(struct timespec time1,
                                    struct timespec time0)
{
    struct timespec ret;
    int xsec = 0;
    int sign = 1;

    if (time0.tv_nsec > time1.tv_nsec) {
        xsec = (int) ((time0.tv_nsec - time1.tv_nsec) / (1E9 + 1));
        time0.tv_nsec -= (long int) (1E9 * xsec);
        time0.tv_sec += xsec;
    }

    if ((time1.tv_nsec - time0.tv_nsec) > 1E9) {
        xsec = (int) ((time1.tv_nsec - time0.tv_nsec) / 1E9);
        time0.tv_nsec += (long int) (1E9 * xsec);
        time0.tv_sec -= xsec;
    }

    ret.tv_sec = time1.tv_sec - time0.tv_sec;
    ret.tv_nsec = time1.tv_nsec - time0.tv_nsec;

    if (time1.tv_sec < time0.tv_sec) {
        sign = -1;
    }

    ret.tv_sec = ret.tv_sec * sign;

    return ret;
}

static double cm_secdiff(struct timespec clock1, struct timespec clock0)
{
    double ret;
    struct timespec diff;

    diff = cm_tspecdiff(clock1, clock0);

    ret = diff.tv_sec;
    ret += (double) diff.tv_nsec / (double) 1E9;

    return ret;
}
#endif /* HAVE_STRUCT_TIMESPEC */

/****************************************************************************
 * CMOCKA TEST RUNNER
 ****************************************************************************/
static int cmocka_run_one_test_or_fixture(const char *function_name,
                                          CMUnitTestFunction test_func,
                                          CMFixtureFunction setup_func,
                                          CMFixtureFunction teardown_func,
                                          void ** const volatile state,
                                          const void *const heap_check_point)
{
    const ListNode * const volatile check_point = (const ListNode*)
        (heap_check_point != NULL ?
         heap_check_point : check_point_allocated_blocks());
    int handle_exceptions = 1;
    void *current_state = NULL;
    int rc = 0;

    /* FIXME check only one test or fixture is set */

    /* Detect if we should handle exceptions */
#ifdef _WIN32
    handle_exceptions = !IsDebuggerPresent();
#endif /* _WIN32 */
#ifdef UNIT_TESTING_DEBUG
    handle_exceptions = 0;
#endif /* UNIT_TESTING_DEBUG */


    if (handle_exceptions) {
#ifndef _WIN32
        unsigned int i;
        for (i = 0; i < ARRAY_SIZE(exception_signals); i++) {
            default_signal_functions[i] = signal(
                    exception_signals[i], exception_handler);
        }
#else /* _WIN32 */
        previous_exception_filter = SetUnhandledExceptionFilter(
                exception_filter);
#endif /* !_WIN32 */
    }

    /* Init the test structure */
    initialize_testing(function_name);

    global_running_test = 1;

    if (setjmp(global_run_test_env) == 0) {
        if (test_func != NULL) {
            test_func(state != NULL ? state : &current_state);

            fail_if_blocks_allocated(check_point, function_name);
            rc = 0;
        } else if (setup_func != NULL) {
            rc = setup_func(state != NULL ? state : &current_state);

            /*
             * For setup we can ignore any allocated blocks. We just need to
             * ensure they're deallocated on tear down.
             */
        } else if (teardown_func != NULL) {
            rc = teardown_func(state != NULL ? state : &current_state);

            fail_if_blocks_allocated(check_point, function_name);
        } else {
            /* ERROR */
        }
        fail_if_leftover_values(function_name);
        global_running_test = 0;
    } else {
        /* TEST FAILED */
        global_running_test = 0;
        rc = -1;
    }
    teardown_testing(function_name);

    if (handle_exceptions) {
#ifndef _WIN32
        unsigned int i;
        for (i = 0; i < ARRAY_SIZE(exception_signals); i++) {
            signal(exception_signals[i], default_signal_functions[i]);
        }
#else /* _WIN32 */
        if (previous_exception_filter) {
            SetUnhandledExceptionFilter(previous_exception_filter);
            previous_exception_filter = NULL;
        }
#endif /* !_WIN32 */
    }

    return rc;
}

static int cmocka_run_group_fixture(const char *function_name,
                                    CMFixtureFunction setup_func,
                                    CMFixtureFunction teardown_func,
                                    void **state,
                                    const void *const heap_check_point)
{
    int rc;

    if (setup_func != NULL) {
        rc = cmocka_run_one_test_or_fixture(function_name,
                                        NULL,
                                        setup_func,
                                        NULL,
                                        state,
                                        heap_check_point);
    } else {
        rc = cmocka_run_one_test_or_fixture(function_name,
                                        NULL,
                                        NULL,
                                        teardown_func,
                                        state,
                                        heap_check_point);
    }

    return rc;
}

static int cmocka_run_one_tests(struct CMUnitTestState *test_state)
{
#ifdef HAVE_STRUCT_TIMESPEC
    struct timespec start = {
        .tv_sec = 0,
        .tv_nsec = 0,
    };
    struct timespec finish = {
        .tv_sec = 0,
        .tv_nsec = 0,
    };
#endif
    int rc = 0;

    /* Run setup */
    if (test_state->test->setup_func != NULL) {
        /* Setup the memory check point, it will be evaluated on teardown */
        test_state->check_point = check_point_allocated_blocks();

        rc = cmocka_run_one_test_or_fixture(test_state->test->name,
                                            NULL,
                                            test_state->test->setup_func,
                                            NULL,
                                            &test_state->state,
                                            test_state->check_point);
        if (rc != 0) {
            test_state->status = CM_TEST_ERROR;
            cm_print_error("Test setup failed");
        }
    }

    /* Run test */
#ifdef HAVE_STRUCT_TIMESPEC
    CMOCKA_CLOCK_GETTIME(CLOCK_REALTIME, &start);
#endif

    if (rc == 0) {
        rc = cmocka_run_one_test_or_fixture(test_state->test->name,
                                            test_state->test->test_func,
                                            NULL,
                                            NULL,
                                            &test_state->state,
                                            NULL);
        if (rc == 0) {
            test_state->status = CM_TEST_PASSED;
        } else {
            if (global_skip_test) {
                test_state->status = CM_TEST_SKIPPED;
                global_skip_test = 0; /* Do not skip the next test */
            } else {
                test_state->status = CM_TEST_FAILED;
            }
        }
        rc = 0;
    }

    test_state->runtime = 0.0;

#ifdef HAVE_STRUCT_TIMESPEC
    CMOCKA_CLOCK_GETTIME(CLOCK_REALTIME, &finish);
    test_state->runtime = cm_secdiff(finish, start);
#endif

    /* Run teardown */
    if (rc == 0 && test_state->test->teardown_func != NULL) {
        rc = cmocka_run_one_test_or_fixture(test_state->test->name,
                                            NULL,
                                            NULL,
                                            test_state->test->teardown_func,
                                            &test_state->state,
                                            test_state->check_point);
        if (rc != 0) {
            test_state->status = CM_TEST_ERROR;
            cm_print_error("Test teardown failed");
        }
    }

    test_state->error_message = cm_error_message;
    cm_error_message = NULL;

    return rc;
}

int _cmocka_run_group_tests(const char *group_name,
                            const struct CMUnitTest * const tests,
                            const size_t num_tests,
                            CMFixtureFunction group_setup,
                            CMFixtureFunction group_teardown)
{
    struct CMUnitTestState *cm_tests;
    const ListNode *group_check_point = check_point_allocated_blocks();
    void *group_state = NULL;
    size_t total_failed = 0;
    size_t total_passed = 0;
    size_t total_executed = 0;
    size_t total_errors = 0;
    size_t total_skipped = 0;
    double total_runtime = 0;
    size_t i;
    int rc;

    /* Make sure LargestIntegralType is at least the size of a pointer. */
    assert_true(sizeof(LargestIntegralType) >= sizeof(void*));

    cm_tests = (struct CMUnitTestState *)libc_malloc(sizeof(struct CMUnitTestState) * num_tests);
    if (cm_tests == NULL) {
        return -1;
    }

    cmprintf_group_start(num_tests);

    /* Setup cmocka test array */
    for (i = 0; i < num_tests; i++) {
        cm_tests[i] = (struct CMUnitTestState) {
            .test = &tests[i],
            .status = CM_TEST_NOT_STARTED,
            .state = NULL,
        };
    }

    rc = 0;

    /* Run group setup */
    if (group_setup != NULL) {
        rc = cmocka_run_group_fixture("cmocka_group_setup",
                                      group_setup,
                                      NULL,
                                      &group_state,
                                      group_check_point);
    }

    if (rc == 0) {
        /* Execute tests */
        for (i = 0; i < num_tests; i++) {
            struct CMUnitTestState *cmtest = &cm_tests[i];
            size_t test_number = i + 1;

            cmprintf(PRINTF_TEST_START, test_number, cmtest->test->name, NULL);

            if (group_state != NULL) {
                cm_tests[i].state = group_state;
            }
            rc = cmocka_run_one_tests(cmtest);
            total_executed++;
            total_runtime += cmtest->runtime;
            if (rc == 0) {
                switch (cmtest->status) {
                    case CM_TEST_PASSED:
                        cmprintf(PRINTF_TEST_SUCCESS,
                                 test_number,
                                 cmtest->test->name,
                                 cmtest->error_message);
                        total_passed++;
                        break;
                    case CM_TEST_SKIPPED:
                        cmprintf(PRINTF_TEST_SKIPPED,
                                 test_number,
                                 cmtest->test->name,
                                 cmtest->error_message);
                        total_skipped++;
                        break;
                    case CM_TEST_FAILED:
                        cmprintf(PRINTF_TEST_FAILURE,
                                 test_number,
                                 cmtest->test->name,
                                 cmtest->error_message);
                        total_failed++;
                        break;
                    default:
                        cmprintf(PRINTF_TEST_ERROR,
                                 test_number,
                                 cmtest->test->name,
                                 "Internal cmocka error");
                        total_errors++;
                        break;
                }
            } else {
                cmprintf(PRINTF_TEST_ERROR,
                         test_number,
                         cmtest->test->name,
                         "Could not run the test - check test fixtures");
                total_errors++;
            }
        }
    } else {
        cmprintf(PRINTF_TEST_ERROR, 0,
                 group_name, "Group setup failed");
        total_errors++;
    }

    /* Run group teardown */
    if (group_teardown != NULL) {
        rc = cmocka_run_group_fixture("cmocka_group_teardown",
                                      NULL,
                                      group_teardown,
                                      &group_state,
                                      group_check_point);
    }

    cmprintf_group_finish(group_name,
                          total_executed,
                          total_passed,
                          total_failed,
                          total_errors,
                          total_skipped,
                          total_runtime,
                          cm_tests);

    for (i = 0; i < num_tests; i++) {
        vcm_free_error(discard_const_p(char, cm_tests[i].error_message));
    }
    libc_free(cm_tests);
    fail_if_blocks_allocated(group_check_point, "cmocka_group_tests");

    return total_failed + total_errors;
}

/****************************************************************************
 * DEPRECATED TEST RUNNER
 ****************************************************************************/

int _run_test(
        const char * const function_name,  const UnitTestFunction Function,
        void ** const volatile state, const UnitTestFunctionType function_type,
        const void* const heap_check_point) {
    const ListNode * const volatile check_point = (const ListNode*)
        (heap_check_point ?
         heap_check_point : check_point_allocated_blocks());
    void *current_state = NULL;
    volatile int rc = 1;
    int handle_exceptions = 1;
#ifdef _WIN32
    handle_exceptions = !IsDebuggerPresent();
#endif /* _WIN32 */
#ifdef UNIT_TESTING_DEBUG
    handle_exceptions = 0;
#endif /* UNIT_TESTING_DEBUG */

    cm_error_message_enabled = 0;

    if (handle_exceptions) {
#ifndef _WIN32
        unsigned int i;
        for (i = 0; i < ARRAY_SIZE(exception_signals); i++) {
            default_signal_functions[i] = signal(
                exception_signals[i], exception_handler);
        }
#else /* _WIN32 */
        previous_exception_filter = SetUnhandledExceptionFilter(
            exception_filter);
#endif /* !_WIN32 */
    }

    if (function_type == UNIT_TEST_FUNCTION_TYPE_TEST) {
        print_message("[ RUN      ] %s\n", function_name);
    }
    initialize_testing(function_name);
    global_running_test = 1;
    if (setjmp(global_run_test_env) == 0) {
        Function(state ? state : &current_state);
        fail_if_leftover_values(function_name);

        /* If this is a setup function then ignore any allocated blocks
         * only ensure they're deallocated on tear down. */
        if (function_type != UNIT_TEST_FUNCTION_TYPE_SETUP) {
            fail_if_blocks_allocated(check_point, function_name);
        }

        global_running_test = 0;

        if (function_type == UNIT_TEST_FUNCTION_TYPE_TEST) {
            print_message("[       OK ] %s\n", function_name);
        }
        rc = 0;
    } else {
        global_running_test = 0;
        print_message("[  FAILED  ] %s\n", function_name);
    }
    teardown_testing(function_name);

    if (handle_exceptions) {
#ifndef _WIN32
        unsigned int i;
        for (i = 0; i < ARRAY_SIZE(exception_signals); i++) {
            signal(exception_signals[i], default_signal_functions[i]);
        }
#else /* _WIN32 */
        if (previous_exception_filter) {
            SetUnhandledExceptionFilter(previous_exception_filter);
            previous_exception_filter = NULL;
        }
#endif /* !_WIN32 */
    }

    return rc;
}


int _run_tests(const UnitTest * const tests, const size_t number_of_tests) {
    /* Whether to execute the next test. */
    int run_next_test = 1;
    /* Whether the previous test failed. */
    int previous_test_failed = 0;
    /* Whether the previous setup failed. */
    int previous_setup_failed = 0;
    /* Check point of the heap state. */
    const ListNode * const check_point = check_point_allocated_blocks();
    /* Current test being executed. */
    size_t current_test = 0;
    /* Number of tests executed. */
    size_t tests_executed = 0;
    /* Number of failed tests. */
    size_t total_failed = 0;
    /* Number of setup functions. */
    size_t setups = 0;
    /* Number of teardown functions. */
    size_t teardowns = 0;
    size_t i;
    /*
     * A stack of test states.  A state is pushed on the stack
     * when a test setup occurs and popped on tear down.
     */
    TestState* test_states =
	    (TestState*)malloc(number_of_tests * sizeof(*test_states));
    /* The number of test states which should be 0 at the end */
    long number_of_test_states = 0;
    /* Names of the tests that failed. */
    const char** failed_names = (const char**)malloc(number_of_tests *
                                       sizeof(*failed_names));
    void **current_state = NULL;

    /* Count setup and teardown functions */
    for (i = 0; i < number_of_tests; i++) {
        const UnitTest * const test = &tests[i];

        if (test->function_type == UNIT_TEST_FUNCTION_TYPE_SETUP) {
            setups++;
        }

        if (test->function_type == UNIT_TEST_FUNCTION_TYPE_TEARDOWN) {
            teardowns++;
        }
    }

    print_message("[==========] Running %"PRIdS " test(s).\n",
                  number_of_tests - setups - teardowns);

    /* Make sure LargestIntegralType is at least the size of a pointer. */
    assert_true(sizeof(LargestIntegralType) >= sizeof(void*));

    while (current_test < number_of_tests) {
        const ListNode *test_check_point = NULL;
        TestState *current_TestState;
        const UnitTest * const test = &tests[current_test++];
        if (!test->function) {
            continue;
        }

        switch (test->function_type) {
        case UNIT_TEST_FUNCTION_TYPE_TEST:
            if (! previous_setup_failed) {
                run_next_test = 1;
            }
            break;
        case UNIT_TEST_FUNCTION_TYPE_SETUP: {
            /* Checkpoint the heap before the setup. */
            current_TestState = &test_states[number_of_test_states++];
            current_TestState->check_point = check_point_allocated_blocks();
            test_check_point = current_TestState->check_point;
            current_state = &current_TestState->state;
            *current_state = NULL;
            run_next_test = 1;
            break;
        }
        case UNIT_TEST_FUNCTION_TYPE_TEARDOWN:
            /* Check the heap based on the last setup checkpoint. */
            assert_true(number_of_test_states);
            current_TestState = &test_states[--number_of_test_states];
            test_check_point = current_TestState->check_point;
            current_state = &current_TestState->state;
            break;
        default:
            print_error("Invalid unit test function type %d\n",
                        test->function_type);
            exit_test(1);
            break;
        }

        if (run_next_test) {
            int failed = _run_test(test->name, test->function, current_state,
                                   test->function_type, test_check_point);
            if (failed) {
                failed_names[total_failed] = test->name;
            }

            switch (test->function_type) {
            case UNIT_TEST_FUNCTION_TYPE_TEST:
                previous_test_failed = failed;
                total_failed += failed;
                tests_executed ++;
                break;

            case UNIT_TEST_FUNCTION_TYPE_SETUP:
                if (failed) {
                    total_failed ++;
                    tests_executed ++;
                    /* Skip forward until the next test or setup function. */
                    run_next_test = 0;
                    previous_setup_failed = 1;
                }
                previous_test_failed = 0;
                break;

            case UNIT_TEST_FUNCTION_TYPE_TEARDOWN:
                /* If this test failed. */
                if (failed && !previous_test_failed) {
                    total_failed ++;
                }
                break;
            default:
#ifndef _HPUX
                assert_null("BUG: shouldn't be here!");
#endif
                break;
            }
        }
    }

    print_message("[==========] %"PRIdS " test(s) run.\n", tests_executed);
    print_error("[  PASSED  ] %"PRIdS " test(s).\n", tests_executed - total_failed);

    if (total_failed > 0) {
        print_error("[  FAILED  ] %"PRIdS " test(s), listed below:\n", total_failed);
        for (i = 0; i < total_failed; i++) {
            print_error("[  FAILED  ] %s\n", failed_names[i]);
        }
    } else {
        print_error("\n %"PRIdS " FAILED TEST(S)\n", total_failed);
    }

    if (number_of_test_states != 0) {
        print_error("[  ERROR   ] Mismatched number of setup %"PRIdS " and "
                    "teardown %"PRIdS " functions\n", setups, teardowns);
        total_failed = (size_t)-1;
    }

    free(test_states);
    free((void*)failed_names);

    fail_if_blocks_allocated(check_point, "run_tests");
    return (int)total_failed;
}

int _run_group_tests(const UnitTest * const tests, const size_t number_of_tests)
{
    UnitTestFunction setup = NULL;
    const char *setup_name;
    size_t num_setups = 0;
    UnitTestFunction teardown = NULL;
    const char *teardown_name;
    size_t num_teardowns = 0;
    size_t current_test = 0;
    size_t i;

    /* Number of tests executed. */
    size_t tests_executed = 0;
    /* Number of failed tests. */
    size_t total_failed = 0;
    /* Check point of the heap state. */
    const ListNode * const check_point = check_point_allocated_blocks();
    const char** failed_names = (const char**)malloc(number_of_tests *
                                       sizeof(*failed_names));
    void **current_state = NULL;
    TestState group_state;

    /* Find setup and teardown function */
    for (i = 0; i < number_of_tests; i++) {
        const UnitTest * const test = &tests[i];

        if (test->function_type == UNIT_TEST_FUNCTION_TYPE_GROUP_SETUP) {
            if (setup == NULL) {
                setup = test->function;
                setup_name = test->name;
                num_setups = 1;
            } else {
                print_error("[  ERROR   ] More than one group setup function detected\n");
                exit_test(1);
            }
        }

        if (test->function_type == UNIT_TEST_FUNCTION_TYPE_GROUP_TEARDOWN) {
            if (teardown == NULL) {
                teardown = test->function;
                teardown_name = test->name;
                num_teardowns = 1;
            } else {
                print_error("[  ERROR   ] More than one group teardown function detected\n");
                exit_test(1);
            }
        }
    }

    print_message("[==========] Running %"PRIdS " test(s).\n",
                  number_of_tests - num_setups - num_teardowns);

    if (setup != NULL) {
        int failed;

        group_state.check_point = check_point_allocated_blocks();
        current_state = &group_state.state;
        *current_state = NULL;
        failed = _run_test(setup_name,
                           setup,
                           current_state,
                           UNIT_TEST_FUNCTION_TYPE_SETUP,
                           group_state.check_point);
        if (failed) {
            failed_names[total_failed] = setup_name;
        }

        total_failed += failed;
        tests_executed++;
    }

    while (current_test < number_of_tests) {
        int run_test = 0;
        const UnitTest * const test = &tests[current_test++];
        if (test->function == NULL) {
            continue;
        }

        switch (test->function_type) {
        case UNIT_TEST_FUNCTION_TYPE_TEST:
            run_test = 1;
            break;
        case UNIT_TEST_FUNCTION_TYPE_SETUP:
        case UNIT_TEST_FUNCTION_TYPE_TEARDOWN:
        case UNIT_TEST_FUNCTION_TYPE_GROUP_SETUP:
        case UNIT_TEST_FUNCTION_TYPE_GROUP_TEARDOWN:
            break;
        default:
            print_error("Invalid unit test function type %d\n",
                        test->function_type);
            break;
        }

        if (run_test) {
            int failed;

            failed = _run_test(test->name,
                               test->function,
                               current_state,
                               test->function_type,
                               NULL);
            if (failed) {
                failed_names[total_failed] = test->name;
            }

            total_failed += failed;
            tests_executed++;
        }
    }

    if (teardown != NULL) {
        int failed;

        failed = _run_test(teardown_name,
                           teardown,
                           current_state,
                           UNIT_TEST_FUNCTION_TYPE_GROUP_TEARDOWN,
                           group_state.check_point);
        if (failed) {
            failed_names[total_failed] = teardown_name;
        }

        total_failed += failed;
        tests_executed++;
    }

    print_message("[==========] %"PRIdS " test(s) run.\n", tests_executed);
    print_error("[  PASSED  ] %"PRIdS " test(s).\n", tests_executed - total_failed);

    if (total_failed) {
        print_error("[  FAILED  ] %"PRIdS " test(s), listed below:\n", total_failed);
        for (i = 0; i < total_failed; i++) {
            print_error("[  FAILED  ] %s\n", failed_names[i]);
        }
    } else {
        print_error("\n %"PRIdS " FAILED TEST(S)\n", total_failed);
    }

    free((void*)failed_names);
    fail_if_blocks_allocated(check_point, "run_group_tests");

    return (int)total_failed;
}

/**
 * @file main.c
 * @author Shreya Chakraborty
 * @brief Main task which spawns the other threads 
 * @version 0.1
 * @date 2019-03-16
 * 
 * @copyright Copyright (c) 2019
 * 
 */
#include "includes.h"
#include "main.h"
#include "logger.h"
#include "temp.h"
#include "socket.h"
#include "light.h"
#include "bist.h"
#include "logger.h"
#include "bbgled.h"
#include "mysignal.h"
#include "bist.h"
#include "heartbeat.h"

pthread_t threads[MAX_TASKS] = {0};
int thread_flag[MAX_TASKS] = {0};
//thread entry functions
void* (*ThreadEntryFunction[MAX_TASKS]) (void*) = 
{
    bist_task,
    logger_task,
    light_task,
    temp_task,
    socket_task
};

const char * moduleIdName[MAX_TASKS+1] = {
    "BIST_TASK",
    "LOGGER_TASK",
    "TEMP_TASK",
    "LIGHT_TASK",
    "SOCKET_TASK",
    "MAIN_TASK",
};
void *threadParamArgs[MAX_TASKS] = {0};


#ifndef TEST_MODE
int main(int argc , char **argv){

    int rc;
    signal(SIGINT,signal_handler);
    logger_queue_init();
    LOG_INFO(MAIN_TASK, "-----Project1 started main thread------");
    if (argc < 2)
    {
        PRINTLOGCONSOLE("Command line Arg Error: USAGE <LOG FILE NAME>");
        GREENLEDOFF();
        REDLEDON();
        exit(EXIT_FAILURE);
    }

    struct loggerTask_param loggerParam = {
        .filename = argv[1],
        .loglevel = LOG_DEBUG
    };

    if(argc == 3){
        loggerParam.loglevel = atoi(argv[2]);
    }

    threadParamArgs[LOGGER_TASK] = (void*)&loggerParam;
    
    //creating all threads except the bist for tasks
    for(int i = 1; i < MAX_TASKS; i++)
    {
        rc = pthread_create(&threads[i],NULL,ThreadEntryFunction[i], threadParamArgs[i]);
        if(rc)
        {
            PRINT("pthread_create for thread %s failed\n", (char*)ThreadEntryFunction[i]);
            GREENLEDOFF();
            REDLEDON();
            exit(EXIT_FAILURE);
        }
        else
        {
            thread_flag[i]=1;
            PRINT("%s thread created\n",moduleIdName[i]);

        }
        
    }
    LOG_INFO(MAIN_TASK, "Threads spawned from the main");

    //Creating bist thread 
    rc = pthread_create(&threads[BIST_TASK],NULL,ThreadEntryFunction[BIST_TASK], threadParamArgs[BIST_TASK]);
    if(rc)
    {
        PRINT("pthread_create for thread %s failed\n", (char*)ThreadEntryFunction[0]);
        GREENLEDOFF();
        REDLEDON();
        exit(EXIT_FAILURE);
    }
    else
    {
        thread_flag[0]=1;
        PRINT("%s thread created\n",moduleIdName[0]);

    }

    //joing only the bist thread initially to do the built in selt tests
    rc = pthread_join(threads[BIST_TASK],NULL);
    if(rc)
    {
        PRINTLOGCONSOLE("pthread_join for thread %s failed\n", (char*)ThreadEntryFunction[0]);
        exit(EXIT_FAILURE);   
    }

    PostBistOkResult(); //if bist has been successful then post semaphores to the rest of the waiting threads
    if(CheckBistResult()) // check if test is successful before joining other threads
    {
        LOG_INFO(MAIN_TASK,"Built in Self Test Result - Pass");
        GREENLEDON();
        REDLEDOFF();
        startHearbeatCheck();// when bist return val is 1 start heartbeat check
    }
    else
    {
        LOG_INFO(MAIN_TASK,"Built in Self Test Result - Fail");
        REDLEDON();   
        GREENLEDOFF(); 
    }

    //joining other threads
    for(int i = 2; i < MAX_TASKS; i++)
    {
        rc = pthread_join(threads[i],NULL);
        if(rc)
        {
            PRINTLOGCONSOLE("pthread_join for thread %s failed\n", (char*)ThreadEntryFunction[i]);
            GREENLEDOFF();
            REDLEDON();
            exit(EXIT_FAILURE);   
        }
    }   

    kill_logger_thread();
    //all tasks have exited. only then exit the logger task to make sure we have all logs
    rc = pthread_join(threads[LOGGER_TASK],NULL);
    if(rc)
    {
        PRINTLOGCONSOLE("pthread_join for thread %s failed\n", (char*)ThreadEntryFunction[LOGGER_TASK]);
        GREENLEDOFF();
        REDLEDON();
        exit(EXIT_FAILURE);   
    }
    
    PRINT("******Program Clean Exit******\n");
    GREENLEDOFF();
    return 0;
}

#endif/**
 * @file logger.c
 * @author Shreya Chakraborty
 * @brief externally connected led functionalities for normal and error conditions
 * @version 0.1
 * @date 2019-03-16
 * 
 * @copyright Copyright (c) 2019
 * 
 */
#include "includes.h"
#include "logger.h"
#include "bbgled.h"
#include "mysignal.h"
#include "heartbeat.h"
#include "bist.h"

static mqd_t mq_logger = -1;
#ifdef TEST_MODE
static log_level_t currentLogLevel = LOG_INVALID;
#else
static log_level_t currentLogLevel = LOG_DEBUG;
#endif
static sig_atomic_t  stop_thread_logger = 0;

const char * logLevel[LOG_MAX] = {
    "LOG_ERR",              //Error conditions
    "LOG_WARNING",          //Warning conditions
    "LOG_INFO",             //Informational
    "LOG_DEBUG"            //Debug-level messages
};
static log_level_t logger_getCurrentLogLevel()
{

  return currentLogLevel;
}

static log_level_t logger_setCurrentLogLevel(log_level_t newLevel)
{
  currentLogLevel = newLevel;
  return currentLogLevel;
}

/**
 * @brief Get the Time Msec object
 * 
 * @return double 
 */
double getTimeMsec()
{
  struct timespec event_ts = {0, 0};
  clock_gettime(CLOCK_REALTIME, &event_ts);
  return ((event_ts.tv_sec) * 1000.0) + ((event_ts.tv_nsec) / 1000000.0);
}

FILE *fp;

#define PRINTLOGFILE(log)  do{\
             printf("[%lf] [%s] [%s] [PID:%d] [TID:%ld] Message: ",getTimeMsec(),logLevel[log.level], moduleIdName[log.srcModuleID],getpid(),syscall(SYS_gettid));\
             printf("%s\n",log.msg );\
             fflush(stdout);\
             fprintf(fp,"[%lf] [%s] [%s] [PID:%d] [TID:%ld] Message: ", getTimeMsec(),logLevel[log.level], moduleIdName[log.srcModuleID],getpid(),syscall(SYS_gettid));\
             fprintf(fp, "%s\n",log.msg );\
             fflush(fp);\
            }while(0) 

int LOG_ENQUEUE(log_level_t level, moduleId_t modId, char *msg, ...)
{
  if(level > currentLogLevel)
  {
    return 0;
  }
  if (mq_logger > -1 && level > LOG_INVALID && level < LOG_MAX)
  {
    log_struct_t send_log;
    send_log.level = level;
    send_log.timestamp = getTimeMsec();
    send_log.srcModuleID = modId;
    va_list arg_ptr;
    va_start(arg_ptr, msg);
    vsnprintf(send_log.msg, sizeof(send_log.msg), msg, arg_ptr);
    va_end(arg_ptr);

    int ret = mq_send(mq_logger, (const char *)&send_log, sizeof(send_log), 0);
    if (ret)
      return ret;

    return EXIT_SUCCESS;
  }

  LOG_ERROR(LOGGER_TASK,"Log enqueue Error");
  GREENLEDOFF();
  REDLEDON();
  return EXIT_FAILURE;
}

mqd_t logger_queue_init(void)
{
  struct mq_attr attr;

  attr.mq_flags = FLAGS;
  attr.mq_maxmsg = MAX_MESSAGES;
  attr.mq_msgsize = sizeof(log_struct_t);
  attr.mq_curmsgs = CURRENT_MSG;

  mq_unlink(LOG_QUEUE_NAME);
  if ((mq_logger = mq_open(LOG_QUEUE_NAME, O_CREAT | O_RDWR, QUEUE_PERMISSIONS, &attr)) == -1)
  {
    perror("Client: mq_open (client)");
    exit(1);
  }

  return mq_logger;
}

void kill_logger_thread(void)
{
  LOG_DEBUG(LOGGER_TASK,"logger exit signal received");
  stop_thread_logger = 1;    
}

#define LOG_EMPTY_CHECK 3
/**
 * @brief call back function for the logger
 * 
 * @param threadp 
 * @return void* 
 */
void *logger_task(void *threadp)
{
  sem_init(&logger_thread_sem,0,0);
  sem_wait(&logger_thread_sem);
  if(!CheckBistResult())
  {
      goto exit;
  }
  //signal_init();
  unsigned int prio;
  struct timespec recv_timeout = {0};
  struct loggerTask_param *params = (struct loggerTask_param *)threadp;
  logger_setCurrentLogLevel(params->loglevel);
  LOG_DEBUG(LOGGER_TASK, "Logger Filename:%s ", params->filename);
  LOG_DEBUG(LOGGER_TASK, "Logger level:%d", params->loglevel);
  LOG_INFO(LOGGER_TASK,"Logger Task thread spawned");

  //log file
  fp = fopen(params->filename, "w+");
  if (fp == NULL)
  {
    PRINTLOGCONSOLE("Could not open file %s\n", params->filename);
    exit(EXIT_FAILURE);
  }
  clock_gettime(CLOCK_REALTIME, &recv_timeout);
  recv_timeout.tv_sec = 1;
  fprintf(fp, "log file created\n");
  log_struct_t recv_log = {0};
  int lastError = 0;
  while(!stop_thread_logger || lastError < LOG_EMPTY_CHECK)
  {
    set_heartbeatFlag(LOGGER_TASK);
    //deque msg
    if (mq_timedreceive(mq_logger, (char*)&recv_log, sizeof(recv_log), &prio, &recv_timeout) == -1) {
        if(!stop_thread_logger && errno == ETIMEDOUT)
        {
          continue;
        }
        else if(stop_thread_logger)
        {
          LOG_DEBUG(LOGGER_TASK, "Logger Timeout: Stop logger:%d, lastErr: %d",stop_thread_logger, lastError);
          lastError++;
          //required sleep here to yield as the lastError check till < 5 
          //takes less than the quantum given to this thread by the scheduler.
          //Having this sleep here allows other thread to run and make 
          //sure to have all the logs from other threads
          usleep(10000);
          continue;
        }
        else
        {
          perror ("Client: mq_receive");
        }  
    }
    else{
    }
    //put the log struct in file
    #ifdef LOG_STDOUT
    PRINTLOGFILE(recv_log);
    #endif
  }
  fclose(fp);
exit:
  PRINTLOGCONSOLE("Logger Task thread exiting");
  return NULL;
}/**
 * @file socket.c
 * @author Shreya Chakraborty
 * @brief Socket thread task functionality
 * @version 0.1
 * @date 2019-03-16
 * 
 * @copyright Copyright (c) 2019
 * 
 */

#include "includes.h"
#include "socket.h"
#include "temp.h"
#include "logger.h"
#include "light.h"
#include "bbgled.h"
#include "mysignal.h"
#include "tempSensor.h"
#include "heartbeat.h"
#include "bist.h"

static sig_atomic_t stop_thread_socket = 0;
extern pthread_t threads[MAX_TASKS];

void kill_socket_thread(void)
{
    LOG_DEBUG(SOCKET_TASK,"socket thread exit signal received");
    stop_thread_socket = 1;
    pthread_cancel(threads[SOCKET_TASK]);    
}

void *socket_task(void *threadp)
{
    sem_init(&temp_thread_sem,0,0);
    sem_wait(&socket_thread_sem);
    if(!CheckBistResult())
    {
        goto exit;
    }
    LOG_INFO(SOCKET_TASK,"Socket task thread spawned");
    int server_fd, new_socket, valread; 
    struct sockaddr_in address; 
    int opt = 1, m = 0; 
    int addrlen = sizeof(address); 
    char buffer[1024] = {0};
    char buffer1[1024] = {0};
    char buffer2[1024] = {0};
    char mesg[1024] ={0};
    char mesg1[1024] ={0}; 
    char mesg2[1024] ={0};
       
    // Creating socket file descriptor 
    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) 
    { 
        perror("socket failed"); 
        exit(EXIT_FAILURE); 
    }
    LOG_INFO(SOCKET_TASK,"Socket has been created"); 
    // Forcefully attaching socket to the port 8080 
    if (setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, 
                                                  &opt, sizeof(opt))) 
    { 
        perror("setsockopt"); 
        exit(EXIT_FAILURE); 
    } 
    address.sin_family = AF_INET; 
    address.sin_addr.s_addr = INADDR_ANY; 
    address.sin_port = htons( PORT ); 
       
    // Forcefully attaching socket to the port 8080 
    if (bind(server_fd, (struct sockaddr *)&address,  
                                 sizeof(address))<0) 
    { 
        perror("bind failed"); 
        exit(EXIT_FAILURE); 
    }
    LOG_INFO(SOCKET_TASK,"socket binded"); 
    if (listen(server_fd, 3) < 0) 
    { 
        perror("listen"); 
        exit(EXIT_FAILURE); 
    }
    LOG_INFO(SOCKET_TASK,"socket listening"); 
    while(!stop_thread_socket)
    {
        set_heartbeatFlag(SOCKET_TASK);
        if ((new_socket = accept(server_fd, (struct sockaddr *)&address,  
                        (socklen_t*)&addrlen))<0) 
        { 
            perror("accept"); 
            exit(EXIT_FAILURE); 
        }
        LOG_INFO(SOCKET_TASK,"socket connection accepted from Remote Client"); 
        while(!stop_thread_socket)
        {
            mesg[1024] = '\0';
            mesg1[1024] = '\0';
            mesg2[1024] = '\0';
            valread = read( new_socket , buffer, 1024); 
            if(strcmp(buffer,"\0") == 0)
            {
                LOG_INFO(SOCKET_TASK,"Socket disconnected from remote client");
                break;
            }
            LOG_INFO(SOCKET_TASK,"Remote Client request number is %s",buffer ); 
            
            if(strcmp(buffer,"1") == 0)
            {
                sprintf(mesg,"Temperature Requested is %f",GET_TEMP_CELCIUS());
                send(new_socket , mesg , strlen(mesg) , 0 );
            }
            if(strcmp(buffer,"2") == 0)
            {
                sprintf(mesg,"Light value Requested is %f",GETLUX());
                send(new_socket , mesg , strlen(mesg) , 0 );
            }
            if(strcmp(buffer,"3") == 0)
            {
                sprintf(mesg,"Temperature value in kelvin is %f",GET_TEMP_KELVIN());
                send(new_socket , mesg , strlen(mesg) , 0 );
            }
            if(strcmp(buffer,"4") == 0)
            {
                sprintf(mesg,"Temperature value in celcius is %f",GET_TEMP_CELCIUS());
                send(new_socket , mesg , strlen(mesg) , 0 );
            }
            if(strcmp(buffer,"5") == 0)
            {
                sprintf(mesg,"Temperature value in Farenheit is %f",GET_TEMP_FARENHEIT());
                send(new_socket , mesg , strlen(mesg) , 0 );
            }
            if(strcmp(buffer,"a") == 0)
            {
                sprintf(mesg,"Request to Kill Temp thread");
                kill_temp_thread();
                send(new_socket , mesg , strlen(mesg) , 0 );
            }
            if(strcmp(buffer,"b") == 0)
            {
                sprintf(mesg,"Request to Kill Light thread");
                kill_light_thread();
                send(new_socket , mesg , strlen(mesg) , 0 );
            }
            if(strcmp(buffer,"c") == 0)
            {
                sprintf(mesg,"Request to Kill Logger thread");
                kill_logger_thread();
                send(new_socket , mesg , strlen(mesg) , 0 );
            }
            if(strcmp(buffer,"7") == 0)
            {
                char *p;
                int i = 0;
                float f_val[2] = {0.0};
                sprintf(mesg1,"threshold values for temp");
                send(new_socket , mesg1 , strlen(mesg1) , 0 ); 
                valread = read( new_socket , buffer1, 1024); 
                p = strtok(buffer1,",");
                while(p != NULL)
                {
                    f_val[i] = atof(p);
                    p = strtok(NULL,",");
                    i++;
                }
                LOG_DEBUG(SOCKET_TASK,"flow and fhigh are %f and %f",f_val[0],f_val[1]);
                RemoteThresholdValues(f_val[0],f_val[1]);
            }
            if(strcmp(buffer,"8") == 0)
            {
                char *p;
                int i = 0;
                uint16_t val[2] = {0.0};
                sprintf(mesg2,"threshold values for light");
                send(new_socket , mesg2 , strlen(mesg2) , 0 ); 
                valread = read( new_socket , buffer2, 1024); 
                p = strtok(buffer2,",");
                while(p != NULL)
                {
                    val[i] = atof(p);
                    p = strtok(NULL,",");
                    i++;
                }
                LOG_DEBUG(SOCKET_TASK,"low and high light threshold are %d and %d",val[0],val[1]);
                RemoteThresholdValueslight(val[0],val[1]);
            }
            
            if(strcmp(buffer,"9") == 0)
            {
                LOG_INFO(SOCKET_TASK,"Client has requested program to exit");
                SystemExit();
            } 
            if(strcmp(buffer,"0") == 0)
            {
                LOG_INFO(SOCKET_TASK,"Client has exited");
                break;
            } 
            LOG_INFO(SOCKET_TASK,"Client Request processed");
        }

    }
    close(new_socket);
exit:
    PRINTLOGCONSOLE("Socket task closed");
    LOG_INFO(SOCKET_TASK,"Socket task closed");
    return NULL;
}

/**
 * @file tempSensor.c
 * @author Shreya Chakraborty
 * @brief TMP102 temperature register functions
 * @version 0.1
 * @date 2019-03-31
 * 
 * @copyright Copyright (c) 2019
 * 
 */
#include "includes.h"
#include "tempSensor.h"
#include "myI2C.h"
#include "logger.h"
#include "main.h"


int TMP102_getTemperature(float *temp_val)
{
    uint8_t tempbuff[2] = {0};
    uint8_t MSB, LSB;
    int ret = I2C_read_bytes(&i2c_handler,TMP102_SLAVE_ADDRESS , TMP102_TEMP_REG, tempbuff, sizeof(tempbuff));
    if(ret == -1 || ret == 1)
    {
        return ret;
    }
    uint16_t result = 0;
    MSB = tempbuff[0];
    LSB = tempbuff[1];
    result = (((uint16_t)MSB << 8) | LSB) >> 4;
    if(result & 0x800) //check for negative temperature
    {
        result = ((~result) + 1); 
        *temp_val = (-1) * result * 0.0625;
    }
    else{
        *temp_val = result * 0.0625;
    }
    return EXIT_SUCCESS;
}

/* what is write pointer register?*/
// read tlow register
int TMP102_getTlow(float *tlow_val)
{
    uint16_t result = 0;
    int ret1 = I2C_read_bytes(&i2c_handler,TMP102_SLAVE_ADDRESS ,TMP102_TLOW_REG, (uint8_t*)&result,sizeof(ret1));
    if(ret1 < 0)
    {
        return EXIT_FAILURE;
    }
    if(result & 0x800) //check for negative temperature
    {
        result = ((~result) + 1); 
        *tlow_val = (-1) * (float)result;
    }
    else{
        *tlow_val = (float)result;
    }
    return EXIT_SUCCESS;  
}

int TMP102_getThigh(float *thigh_val)
{
    uint16_t result = 0;
    int ret1 = I2C_read_bytes(&i2c_handler,TMP102_SLAVE_ADDRESS ,TMP102_THIGH_REG, (uint8_t*)&result,sizeof(uint16_t));
    if(ret1 < 0)
    {
        return EXIT_FAILURE;
    }
    if(result & 0x800) //check for negative temperature
    {
        result = ((~result) + 1); 
        *thigh_val = (-1) * (float)result;
    }
    else{
        *thigh_val = (float)result;
    }
    return EXIT_SUCCESS;     
}

int TMP102_setThigh(float thigh_val) // default value is 80 deg celcius 
{
    uint16_t result = 0;
    thigh_val = thigh_val/0.0625;
    //get raw temp value from the parameter and check for negative values
    if(thigh_val > 0)
    {
        result = ((uint16_t)thigh_val >> 4);// tlow is 12 bits in normal mode.
    }
    else
    {
        thigh_val = -1 * thigh_val;
        result = (uint16_t)thigh_val;
        result = ((~result) + 1); 
        result >>= 4;
    }

    int ret1 = I2C_write_word(&i2c_handler,TMP102_SLAVE_ADDRESS ,TMP102_THIGH_REG,result);
    if(ret1)
        return EXIT_FAILURE;
    return EXIT_SUCCESS;
}

int TMP102_setTlow(float tlow_val) //default value is 75 deg celcius
{
    uint16_t result = 0;
    tlow_val = tlow_val/0.0625;
    //get raw temp value from the parameter and check for negative values
    if(tlow_val > 0)
    {
        result = ((uint16_t)tlow_val >> 4);// tlow is 12 bits in normal mode.
        result &= 0x7FFF;
    }
    else
    {
        tlow_val = -1 * tlow_val;
        result = (uint16_t)tlow_val;
        result = ((~result) + 1); 
        result >>= 4;
    }

    int ret1 = I2C_write_word(&i2c_handler,TMP102_SLAVE_ADDRESS ,TMP102_TLOW_REG,result);
    if(ret1)
        return EXIT_FAILURE;
    return EXIT_SUCCESS;

}

int TMP102_readReg(uint8_t reg, uint8_t *data)
{
    int ret1 = I2C_read_bytes(&i2c_handler,TMP102_SLAVE_ADDRESS,reg,data, sizeof(data));
    if(ret1 < 0)
    {
        return EXIT_FAILURE;
    }
    return EXIT_SUCCESS;
}

int TMP102_writePTRreg(uint8_t reg)
{
    int ret1 = I2C_write_byte(&i2c_handler,TMP102_SLAVE_ADDRESS,reg);
    if(ret1 != 0)
    {
        return EXIT_FAILURE;
    }
    return EXIT_SUCCESS;
}

int TMP102_setShutdownMode(shutdown_mode_t option) //SD bit in config register default is DEFAULT
{
    uint16_t SD_mode = 0;
    //read the set value from the configuration register
    int ret1 = I2C_read_bytes(&i2c_handler,TMP102_SLAVE_ADDRESS,TMP102_CONFIG_REG,(uint8_t*)&SD_mode,sizeof(SD_mode));
    if(ret1 < 0)
    {
        return EXIT_FAILURE;
    }
    if(option == POWERSAVING)
    {
        SD_mode = SD_mode | (uint16_t)TMP102_CONF_SD;
    }
    else //default, continuous mode
    {
        SD_mode = SD_mode & ~((uint16_t)TMP102_CONF_SD);
    }
    ret1 = I2C_write_word(&i2c_handler,TMP102_SLAVE_ADDRESS,TMP102_CONFIG_REG,SD_mode);
    if(ret1 != 0)
    {
        return EXIT_FAILURE;
    }
    return EXIT_SUCCESS;
}


//sensor resolution R1/R0, option - 0 is default 12 bits
int TMP102_setResolution(sensor_resolution_t option) //default R0R1 set
{
    uint16_t resolution = (uint16_t)0;
    int ret1 = I2C_read_bytes(&i2c_handler,TMP102_SLAVE_ADDRESS,TMP102_CONFIG_REG,(uint8_t*)&resolution,sizeof(resolution));
    
    if(ret1 < 0)
    {
        return EXIT_FAILURE;
    }
    if(option == R0R1_SET) // default resolution -RO and R1 set
    {
        resolution = resolution | (uint16_t)TMP102_CONF_R0 | (uint16_t)TMP102_CONF_R1;    
    }
    else if( option == R1_SET) // R1 set R0 clear
    {
        resolution &= ~(uint16_t)TMP102_CONF_R0;
        resolution |= (uint16_t)TMP102_CONF_R1;
    }
    else if(option == R0_SET) //RO set R1 clear
    {
        resolution &= ~(uint16_t)TMP102_CONF_R1;
        resolution |= (uint16_t)TMP102_CONF_R0;
    }
    else 
    {
        resolution &= ~(uint16_t)TMP102_CONF_R0;
        resolution &= ~(uint16_t)TMP102_CONF_R1;
        //do nothing
    }
    ret1 = I2C_write_word(&i2c_handler,TMP102_SLAVE_ADDRESS,TMP102_CONFIG_REG,resolution);
    if(ret1 != 0)
    {
        return EXIT_FAILURE;
    }
    return EXIT_SUCCESS;

}

int TMP102_getFaultbits(uint16_t *data) // default mode is F1 AND F0 clear
{
    uint16_t config = 0;
    int ret = I2C_read_bytes(&i2c_handler,TMP102_SLAVE_ADDRESS,TMP102_CONFIG_REG,(uint8_t*)&config, sizeof(uint16_t));
    if(ret == -1)
    {
        return EXIT_FAILURE;
    }
    *data = config & FAULTBITSMASK;
    return EXIT_SUCCESS;
}

int TMP102_setFaultbits(fault_setting_t option) //default is 1 fault
{
    uint16_t setting = 0;
    int ret1 = I2C_read_bytes(&i2c_handler,TMP102_SLAVE_ADDRESS,TMP102_CONFIG_REG,(uint8_t*)&setting,sizeof(setting));
    
    if(option == SIX_FAULTS) // FO and F1 set
    {
        setting |= (uint16_t)TMP102_CONF_F0;
        setting |= (uint16_t)TMP102_CONF_F1; 
    }
    else if( option == FOUR_FAULTS) // F1 set F0 clear
    {
        setting &= (~(uint16_t)TMP102_CONF_F0);
        setting |= ((uint16_t)TMP102_CONF_F1);
    }
    else if(option == TWO_FAULTS) //FO set F1 clear
    {
        setting &= ~(uint16_t)TMP102_CONF_F1;
        setting |= (uint16_t)TMP102_CONF_F0;
    }
    else //(option == ONE_FAULT)
    {
        // nothing
        setting &= ~(uint16_t)TMP102_CONF_F0;
        setting &= ~(uint16_t)TMP102_CONF_F1;
    }
    //printf("settings :0x%x\n",setting);  
    ret1 = I2C_write_word(&i2c_handler,TMP102_SLAVE_ADDRESS,TMP102_CONFIG_REG,setting);
    if(ret1 != 0)
    {
        return EXIT_FAILURE;
    }
    return EXIT_SUCCESS;
}

int TMP102_setEM(EM_mode_t option)// default is normal mode
{
    uint16_t EM_mode = 0;
    int ret1 = I2C_read_bytes(&i2c_handler,TMP102_SLAVE_ADDRESS,TMP102_CONFIG_REG,(uint8_t*)&EM_mode,sizeof(EM_mode));
    if(ret1 < 0)
    {
        return EXIT_FAILURE;
    }
    if(option == EXTENDED)
    {  
        EM_mode = EM_mode | (uint16_t)TMP102_CONF_EM; 
    }
    else //default
    {
        EM_mode = EM_mode & ~((uint16_t)TMP102_CONF_EM);
    }
    ret1 = I2C_write_word(&i2c_handler,TMP102_SLAVE_ADDRESS,TMP102_CONFIG_REG,EM_mode);
    if(ret1 != 0)
    {
        return EXIT_FAILURE;
    }
    return EXIT_SUCCESS;

}

int TMP102_setCR(conversion_rate_t option)
{
    uint16_t CR_mode = 0;
    int ret1 = I2C_read_bytes(&i2c_handler,TMP102_SLAVE_ADDRESS,TMP102_CONFIG_REG,(uint8_t*)&CR_mode,sizeof(CR_mode));
    if(ret1 < 0)
    {
        return EXIT_FAILURE;
    } 
    
    if(option == EIGHT_HZ) 
    {
        CR_mode = CR_mode | (uint16_t)TMP102_CONF_CR0 | (uint16_t)TMP102_CONF_CR1;    
    }
    else if( option == FOUR_HZ) 
    {
        CR_mode &= ~(uint16_t)TMP102_CONF_CR0;
        CR_mode |= (uint16_t)TMP102_CONF_CR1;
    }
    else if(option == ONE_HZ) 
    {
        CR_mode &= ~(uint16_t)TMP102_CONF_CR1;
        CR_mode |= (uint16_t)TMP102_CONF_CR0;
    }
    else // ONE_FOURTH_HZ
    {
        // nothing
        CR_mode &= ~(uint16_t)TMP102_CONF_CR0;
        CR_mode &= ~(uint16_t)TMP102_CONF_CR1;
    } 
    ret1 = I2C_write_word(&i2c_handler,TMP102_SLAVE_ADDRESS,TMP102_CONFIG_REG,CR_mode);
    if(ret1 != 0)
    {
        return EXIT_FAILURE;
    }
    return EXIT_SUCCESS; 
}

int TMP102_readAL( uint8_t *bit)
{
    uint16_t AL = 0;
    *bit = 0;
    int ret1 = I2C_read_bytes(&i2c_handler,TMP102_SLAVE_ADDRESS,TMP102_CONFIG_REG,(uint8_t*)&AL,sizeof(uint16_t));
    if(ret1 < 0)
    {
        return EXIT_FAILURE;
    } 
    *bit = ((AL & (uint16_t)TMP102_CONF_AL) >> 13);
    return EXIT_SUCCESS;
}

int TMP102_setAllDefault(){
    int ret = TMP102_setCR(FOUR_HZ);
    ret |= TMP102_setEM(NORMAL);
    ret |= TMP102_setFaultbits(ONE_FAULT);
    ret |= TMP102_setResolution(R0R1_SET);
    ret |= TMP102_setShutdownMode(DEFAULT);
    if (ret != 0)
    {
        return EXIT_FAILURE;
    }
    return EXIT_SUCCESS;
}
/**
 * @file light.c
 * @author Shreya CHakraborty
 * @brief Light task thread functionality
 * @version 0.1
 * @date 2019-03-31
 * 
 * @copyright Copyright (c) 2019
 * 
 */
#include "includes.h"
#include "light.h"
#include "main.h"
#include "logger.h"
#include "bbgled.h"
#include "mysignal.h"
#include "mytimer.h"
#include "lightSensor.h"
#include "heartbeat.h"
#include "bist.h"
/* mraa header */
#include "mraa/gpio.h"

/* gpio declaration */
#define GPIO_PIN_19     19
#define APDS_INT_PIN    GPIO_PIN_19

static volatile float lux_val = 0.0;
static volatile uint16_t l_low = 0;
static volatile uint16_t l_high = 1200;
static volatile bool thresholdChanged = false;
static int l_sec = 1;
static int l_nsec = 0;
static sig_atomic_t stop_thread_light = 0;
// mraa_gpio_context interrupt_gpio_pin;
int l_count = 0;
pthread_mutex_t light_var_lock = PTHREAD_MUTEX_INITIALIZER;

/**
 * @brief Set the Lux Var object "lux"
 * 
 * @param lux 
 */
static inline void setLuxVar(float lux)
{
    pthread_mutex_lock(&light_var_lock);
    lux_val = lux;
    pthread_mutex_unlock(&light_var_lock);
} 

/**
 * @brief Get the Lux Var object into "lux"
 * 
 * @return float 
 */
static inline float getLuxVar()
{
    float lux = 0;
    pthread_mutex_lock(&light_var_lock);
    lux = lux_val;
    pthread_mutex_unlock(&light_var_lock);
    return lux;
} 


static int readAndUpdateLight(void)
{
    float lux = 0.0;
    /*if(l_count > 4)
    {
        stop_thread_light = 1;   
    }*/
    int ret = APDS9301_getlight(&lux);
    if(ret)
    {
        LOG_ERROR(TEMP_TASK, "APDS9301 light Sensor Disconnected: %d", ret);
        REDLEDON();
        APDS9301_powerup();
        //l_count++;
        return ret;
    } 
    REDLEDOFF();
    setLuxVar(lux);
    LOG_INFO(LIGHT_TASK,"The light is %0.3f lux",lux); 
    if(thresholdChanged)
    {
        LOG_DEBUG(LIGHT_TASK, "Threshold changed Remotely");
        pthread_mutex_lock(&light_var_lock);
        uint16_t llow = l_low;
        uint16_t lhigh = l_high;
        thresholdChanged = false;
        pthread_mutex_unlock(&light_var_lock); 
        if(0 == APDS9301_setLightThreshold(llow, lhigh))
        {
            LOG_INFO(LIGHT_TASK,"Light thresholds changed to 0x%02x and 0x%02x",llow,lhigh);
        }
        else{
            LOG_ERROR(LIGHT_TASK, "Could Not set Ligth threshold");
        }
    }
    LOG_DEBUG(LIGHT_TASK,"Light thresholds are 0x%02x and 0x%02x",l_low,l_high);
    return 0;
}

mraa_gpio_context APDS9301_IntPinSetup(int mraaPinNumber)
{
    mraa_result_t status = MRAA_SUCCESS;
    mraa_gpio_context lightSensorIntPin;
    mraa_init();
    lightSensorIntPin = mraa_gpio_init(mraaPinNumber);
    if (lightSensorIntPin == NULL) {
        LOG_ERROR(LIGHT_TASK, "Failed to initialize GPIO %d", mraaPinNumber);
        return NULL;
    }
    status = mraa_gpio_dir(lightSensorIntPin, MRAA_GPIO_IN);
    if (status != MRAA_SUCCESS) {
        LOG_ERROR(LIGHT_TASK, "Failed to set input direction GPIO %d", mraaPinNumber);
        mraa_gpio_close(lightSensorIntPin);
        return NULL;
    }
    return lightSensorIntPin;
}

int APDS9301_IntPinClose(mraa_gpio_context lightSensorIntPin)
{
    return mraa_gpio_close(lightSensorIntPin);
}

int APDS9301_checkINTPIN(mraa_gpio_context lightSensorIntPin)
{
    int status = mraa_gpio_read(lightSensorIntPin);
    if (status == -1) 
    {
        LOG_ERROR(LIGHT_TASK, "Failed to read GPIO %d", mraa_gpio_get_pin(lightSensorIntPin));
    }
    LOG_DEBUG(LIGHT_TASK, "APDS INT Pin value:%d",status);
    return status;
}

void kill_light_thread(void)
{
    LOG_DEBUG(LIGHT_TASK,"light thread exit signal received");
    stop_thread_light = 1;
    stop_thread_light++;    
}

float getLight(void)
{
    float lux = getLuxVar();
    return lux;
}

static void giveSemSensor(union sigval no)
{
    sem_post(&light_sem);
}

int RemoteThresholdValueslight(uint16_t llow,uint16_t lhigh)
{
    pthread_mutex_lock(&light_var_lock);
    l_low = llow;
    l_high = lhigh;
    thresholdChanged = true;
    pthread_mutex_unlock(&light_var_lock); 
    return 0;
}

int APDS9301_setLightThreshold(uint16_t l_low,uint16_t l_high)
{
    uint8_t th_lowlow,th_hilow,th_lowhi,th_hihi;
    LOG_DEBUG(LIGHT_TASK, "APDS Int pin setup done");
    int ret1 = APDS9301_writeTHRESH_lowlow(l_low); //write 2 byte
    int ret4 = APDS9301_writeTHRESH_highlow(l_high);//write 2 byte
    int ret2 = APDS9301_readTHRESH_lowlow(&th_lowlow);
    ret2 = APDS9301_readTHRESH_lowhigh(&th_lowhi);
    ret2 = APDS9301_readTHRESH_highhigh(&th_hihi);
    ret2 = APDS9301_readTHRESH_highlow(&th_hilow);
    LOG_DEBUG(LIGHT_TASK,"read threshold low val is 0x%02x",th_lowlow | ((uint16_t)th_lowhi)<<8);
    LOG_DEBUG(LIGHT_TASK,"read threshold high val is 0x%02x",th_hilow | ((uint16_t)th_hihi)<<8);
    LOG_INFO(LIGHT_TASK,"Light thresholds are 0x%02x and 0x%02x",th_lowlow | ((uint16_t)th_lowhi)<<8,th_hilow | ((uint16_t)th_hihi)<<8);
    APDS9301_interruptCTRLreg(ENABLE);
    return EXIT_SUCCESS;
}

void *light_task(void *threadp)
{
    sem_init(&light_thread_sem,0,0);
    sem_wait(&light_thread_sem);
    if(!CheckBistResult())
    {
        goto exit;
    }
    LOG_INFO(LIGHT_TASK,"Light task thread spawned");
    mraa_gpio_context interrupt_gpio_pin =  APDS9301_IntPinSetup(APDS_INT_PIN); //mraa_gpio context
    if(interrupt_gpio_pin == NULL)
    {
        goto exit;
    }
    if(APDS9301_setLightThreshold(l_low,l_high) == -1)
    {
        goto exit;
    }
    timer_t light_timer;
    sem_init(&light_sem,0,0);
    if(maketimer(&light_timer, &giveSemSensor) != 0)
    {
        perror("MakeTimer fail");
    }
    LOG_DEBUG(LIGHT_TASK,"The thread frequency is %d sec and %d nsec",l_sec,l_nsec);
    startTimer(light_timer,l_sec,l_nsec);
    while(!stop_thread_light)
    {
        set_heartbeatFlag(LIGHT_TASK);
        if(sem_wait(&light_sem) == 0)
        {
            readAndUpdateLight();
            int pinValue = APDS9301_checkINTPIN(interrupt_gpio_pin);
            if(pinValue == 0)
            {
                LOG_INFO(LIGHT_TASK, "Light sensor Threshold exceeded, It is day outside! (^_^)");
                APDS9301_intClear();
            }
            else
            {
                LOG_INFO(LIGHT_TASK, "Below Light Threshold.It is night outside! (-_-)...");    
            }
            
        }
    }
    APDS9301_IntPinClose(interrupt_gpio_pin);
exit:
    PRINTLOGCONSOLE("Light task thread exiting");
    LOG_INFO(LIGHT_TASK,"Light task thread exiting");
    return NULL;
}/**
 * @file myI2C.c
 * @author Shreya Chakraborty
 * @brief I2C drivers for sensor using mraa library
 * @version 0.1
 * @date 2019-03-22
 * @reference https://iotdk.intel.com/docs/master/mraa/i2c_8h.html#a935c1206dfd241e182de7fe133aadb18
 * @copyright Copyright (c) 2019
 * 
 */

/* mraa header */
#include "includes.h"
#include "myI2C.h"
#include "logger.h"
#include <errno.h>

int I2C_init(i2c_struct_t *i2c_handler)
{
     /* initialize mraa for the platform (not needed most of the times) */
    mraa_init();
    i2c_handler->i2c_context = mraa_i2c_init_raw(I2C_BUS);
    if (i2c_handler->i2c_context == NULL) {
        PRINTLOGCONSOLE("Failed to initialize I2C");
        mraa_deinit();
        return EXIT_FAILURE;
    }
    return EXIT_SUCCESS;
}

int I2C_close(i2c_struct_t *i2c_handler)
{
    i2c_handler->status = mraa_i2c_stop(i2c_handler->i2c_context);
    if(i2c_handler->status != MRAA_SUCCESS)
    {
        PRINTLOGCONSOLE("Failed to stop I2C");
        return EXIT_FAILURE;   
    }
    mraa_deinit();
    return i2c_handler->status;
}

int I2C_set_slave(i2c_struct_t *i2c_handler,uint8_t slave_addr)
{
    i2c_handler->status = mraa_i2c_address(i2c_handler->i2c_context,slave_addr);
    if(i2c_handler->status != MRAA_SUCCESS)
    {
        PRINTLOGCONSOLE("Could not set Slave address");
        return EXIT_FAILURE;
    }
    return i2c_handler->status;
}

int I2C_write_byte(i2c_struct_t *i2c_handler,uint8_t slave_addr,uint8_t data)
{
    if(! I2C_set_slave(i2c_handler,slave_addr))
    {
        i2c_handler->status = mraa_i2c_write_byte(i2c_handler->i2c_context, data);
        if(i2c_handler->status != MRAA_SUCCESS)
        {
            PRINTLOGCONSOLE("Could not write data to Slave address");
            return EXIT_FAILURE;
        }
        else return i2c_handler->status;
    }
    else return EXIT_FAILURE;    
}

int I2C_read_byte(i2c_struct_t *i2c_handler,uint8_t slave_addr,uint8_t command_reg, uint8_t *data)
{
    int ret;
    if(! I2C_set_slave(i2c_handler,slave_addr))
    {
        ret = mraa_i2c_read_byte_data(i2c_handler->i2c_context,command_reg);
        if(ret == -1)
        {
            return EXIT_FAILURE;
        }
        else {
            *data = (uint8_t)ret;
            return EXIT_SUCCESS;
        }
    }
    else return EXIT_FAILURE; 
	    
}

int I2C_read_bytes(i2c_struct_t *i2c_handler,uint8_t slave_addr,uint8_t command_reg, uint8_t *data, size_t length)
{
    int ret;
    if(! I2C_set_slave(i2c_handler,slave_addr))
    {
        ret = mraa_i2c_read_bytes_data(i2c_handler->i2c_context, command_reg, data,length);
        if(ret != length)
        {
            PRINTLOGCONSOLE("Could not read data bytes from register");
            return EXIT_FAILURE;
        }
        else 
        {
            return ret;
        }
    }
    else return EXIT_FAILURE;  
}


//msb byte2 followed by lsb byte1 format
int I2C_write_byte_data(i2c_struct_t *i2c_handler,uint8_t slave_addr,uint8_t command_reg,uint8_t data)
{
    if(! I2C_set_slave(i2c_handler,slave_addr))
    {
        i2c_handler->status = mraa_i2c_write_byte_data(i2c_handler->i2c_context, data, command_reg);
        if(i2c_handler->status != MRAA_SUCCESS)
        {
            PRINTLOGCONSOLE("Could not write data to Slave address");
            return EXIT_FAILURE;
        }
        else return i2c_handler->status;
    }
    else return EXIT_FAILURE;      
}

//msb byte2 followed by lsb byte1 format
int I2C_write_word(i2c_struct_t *i2c_handler,uint8_t slave_addr,uint8_t command_reg,uint16_t data)
{
    if(! I2C_set_slave(i2c_handler,slave_addr))
    {
        i2c_handler->status = mraa_i2c_write_word_data(i2c_handler->i2c_context, data,command_reg);
        if(i2c_handler->status != MRAA_SUCCESS)
        {
            PRINTLOGCONSOLE("Could not write data to Slave address");
            return EXIT_FAILURE;
        }
        else 
        {
            return i2c_handler->status;
        }
    }
    else return EXIT_FAILURE;      
}/**
 * @file client.c
 * @author Shreya Chakraborty
 * @brief Remote Client for the socket task
 * @version 0.1
 * @date 2019-03-31
 * 
 * @copyright Copyright (c) 2019
 * 
 */
#include <stdio.h> 
#include <sys/socket.h> 
#include <stdlib.h> 
#include <netinet/in.h> 
#include <string.h> 
#include <arpa/inet.h>
#include <unistd.h>
#include <stdlib.h>
#define PORT 8888 
   
int main(int argc, char const *argv[]) 
{ 
    struct sockaddr_in address; 
    int sock = 0, valread,m = 0; 
    char c,b,x;
    float t_hi,t_low;
    uint16_t l_hi,l_low;
    uint32_t secs,nanosec;
    struct sockaddr_in serv_addr; 
    char buffer[1024] = {0};
    char buffer1[1024] = {0}; 
    char buffer2[1024] = {0}; 
    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) 
    { 
        printf("\n Socket creation error \n"); 
        return -1; 
    } 
   
    memset(&serv_addr, '0', sizeof(serv_addr)); 
   
    serv_addr.sin_family = AF_INET; 
    serv_addr.sin_port = htons(PORT); 
       
    // Convert IPv4 and IPv6 addresses from text to binary form 
    if(inet_pton(AF_INET, "127.0.0.1", &serv_addr.sin_addr)<=0)  
    { 
        printf("\nInvalid address/ Address not supported \n"); 
        return -1; 
    } 
    if (connect(sock, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0) 
    { 
        printf("\nConnection Failed \n"); 
        return -1; 
    } 
    while(1)
    {
        TRY: printf("Remote Client Request Option:\n");
        printf("1. Request Current Temperature value\n");
        printf("2. Request Current Light value\n");
        printf("3. Request Temperature in Kelvin\n");
        printf("4. Request Temperature in Celsius\n");
        printf("5. Request Temperature in Farenheit\n");
        printf("6. Exit thread of choice\n");
        printf("7. Set Temperature Threshold\n");
        printf("8. Set Light Threshold\n");
        printf("9. Exit the program\n");
        printf("0. Exit Client\n");
        printf("Enter any of the above option.\n");
        c = getchar();
        x = getchar(); //dummy enter
        printf("entered option is %c\n",c);
        if((c < '0') && (c > '9'))
        {
            printf("Invalid Option. Try again..\n");
            goto TRY;
        } 
        if(c == '6') 
        {
            printf("a. Temp Task Thread\n");
            printf("b. Light Task Thread\n");
            printf("c. Logger Task Thread\n"); 
            c = getchar();
            x = getchar(); //dummy enter
            if((c < 'a') && (c > 'c'))
            {
                printf("Invalid Option. Try again..\n");
                goto TRY;
            } 

        }
        if(c == '7') 
        {
            b = '7';
            char flow[20];
            char fhigh[20];
            printf("Enter the upper Temp threshold\n");
            scanf("%f",&t_hi);
            x = getchar(); //dummy enter
            printf("Enter the lower Temp threshold\n");
            scanf("%f",&t_low);
            x = getchar(); //dummy enter
            if((t_low < -56) && (t_hi > 128))
            {
                printf("Invalid Option. Try again..\n");
                goto TRY;
            }
            send(sock , (char*)&b , sizeof(b) , 0 ); //sending request number
            valread = read( sock , buffer1, 1024);
            gcvt(t_hi,6,fhigh);
            gcvt(t_low,6,flow);
            strcat(flow,",");
            strcat(flow,fhigh);
            printf("low and high values entered are %s\n",flow);
            send(sock , (char*)&flow , sizeof(flow) , 0 );
        }
        if(c == '8') 
        {
            b = '8';
            char llow[20];
            char lhigh[20];
            printf("Enter the upper Light threshold\n");
            scanf("%hd",&l_hi);
            x = getchar(); //dummy enter
            printf("Enter the lower Light threshold\n");
            scanf("%hd",&l_low);
            x = getchar(); //dummy enter
            if((l_low < 0) && (l_hi > 128))
            {
                printf("Invalid Option. Try again..\n");
                goto TRY;
            }
            send(sock , (char*)&b , sizeof(b) , 0 ); //sending request number
            valread = read( sock , buffer1, 1024);
            sprintf(lhigh,"%d",l_hi);
            sprintf(llow,"%d",l_low);
            strcat(llow,",");
            strcat(llow,lhigh);
            printf("low and high values entered are %s\n",llow);
            send(sock , (char*)&llow , sizeof(llow) , 0 );
        }
        if(c == '0')
        {
            send(sock , (char*)&c , sizeof(c) , 0 );
            break; 
        }  
        if(c != '7' && c != '8')
        {
            send(sock , (char*)&c , sizeof(c) , 0 ); 
            printf("Client Request Sent\n");
            buffer[1024]= '\0';
            valread = read( sock , buffer, 1024); 
            printf("%s\n",buffer ); 
            
        }
        

    }
    printf("Client exiting....\n");
    close(sock);
    return 0; 
} 
/**
 * @file test.c
 * @author your Shreya Chakraborty
 * @brief Cmoka Testing for Logger
 * @version 0.1
 * @date 2019-03-31
 * 
 * @copyright Copyright (c) 2019
 * 
 */
#include "includes.h"
#include "cmocka.h"
#include <unistd.h>
#include "logger.h"

static void logger_InitTest(void **state)
{
    int ret = logger_queue_init();
    assert_false(ret == -1);
}

static void logger_EnqueueTest(void **state)
{
    int ret = LOG_ENQUEUE(1, 1, "testing");
    assert_int_equal(ret, 0);
}

static void logger_logInfoTest(void **state)
{
    int ret = LOG_INFO(1, "testing");
    assert_int_equal(ret, 0);
}

static void logger_logErrorTest(void **state)
{
    int ret = LOG_ERROR(1, "testing");
    assert_int_equal(ret, 0);
}

static void logger_logWarnTest(void **state)
{
    int ret = LOG_WARN(1, "testing");
    assert_int_equal(ret, 0);
}

static void logger_logDebugTest(void **state)
{
    int ret = LOG_DEBUG(1, "testing");
    assert_int_equal(ret, 0);
}
int main()
{
    const struct CMUnitTest logtests[] = {	
	
    cmocka_unit_test(logger_InitTest),
    cmocka_unit_test(logger_EnqueueTest),
    cmocka_unit_test(logger_logInfoTest),
    cmocka_unit_test(logger_logErrorTest),
    cmocka_unit_test(logger_logWarnTest),
    cmocka_unit_test(logger_logDebugTest)

	};

	return cmocka_run_group_tests(logtests, NULL, NULL);
    printf("testing......\n");
    return 0;

}/**
 * @file test.c
 * @author Shreya Chakraborty
 * @brief Test for gpio pin on BeagleBone Green
 * @version 0.1
 * @date 2019-03-31
 * 
 * @copyright Copyright (c) 2019
 * 
 */
/* standard headers */
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

/* mraa header */
#include "mraa/gpio.h"

/* gpio declaration */
#define GPIO_PIN_19 19

int main(void)
{
    mraa_result_t status = MRAA_SUCCESS;
    mraa_gpio_context gpio_1;
    /* initialize mraa for the platform (not needed most of the times) */
    mraa_init();

    //! [Interesting]
    /* initialize GPIO pin */
    gpio_1 = mraa_gpio_init(GPIO_PIN_19);
    if (gpio_1 == NULL) {
        printf("Failed to initialize GPIO %d\n", GPIO_PIN_19);
        mraa_deinit();
        return EXIT_FAILURE;
    }
    /* set GPIO to input */
    status = mraa_gpio_dir(gpio_1, MRAA_GPIO_IN);
    if (status != MRAA_SUCCESS) {
        //goto err_exit;
        printf("Failed to set input direction GPIO %d\n", GPIO_PIN_19);
    }

    while(1)
    {
        status = mraa_gpio_read(gpio_1);
        if (status == -1) {
            printf("Failed to read GPIO %d\n", GPIO_PIN_19);
            continue;
            //goto err_exit;
        }
        printf("status is %d\n",status);
    
    }
}/**
 * @file test.c
 * @author Shreya Chakraborty
 * @brief Cmoka Unit testing for TMP102 temperature sensor regster functions
 * @version 0.1
 * @date 2019-03-31
 * 
 * @copyright Copyright (c) 2019
 * 
 */
#include "myI2C.h"
#include "tempSensor.h"
#include <unistd.h>
#include "includes.h"
#include "cmocka.h"
#include "temp.h"


// i2c_struct_t i2c_handler;

static void tempSensor_InitTest(void **state)
{
    int ret = I2C_init(&i2c_handler);
    assert_int_equal(ret, 0);
}

static void tempSensor_GetTempTest(void **state)
{
    float temp_val;
    int ret = TMP102_getTemperature(&temp_val);
    assert_int_equal(ret, 0);
}

static void tempSensor_THighTest(void **state)
{
    float thighIn = 30.0, thighOut;
    int ret = TMP102_setThigh(thighIn);
    assert_int_equal(ret, 0);
    ret = TMP102_getThigh(&thighOut);
    assert_int_equal(ret, 0);
    assert_true(thighIn == thighOut);
}

static void tempSensor_TLowTest(void **state)
{
    float thighIn = 30.0, thighOut;
    int ret = TMP102_setTlow(thighIn);
    assert_int_equal(ret, 0);
    ret = TMP102_getTlow(&thighOut);
    assert_int_equal(ret, 0);
    assert_true(thighIn == thighOut);
}

static void tempSensor_WritePtrReg(void **state)
{
    int ret = TMP102_writePTRreg(TMP102_CONF_TM);
    assert_int_equal(ret, 0);
}

static void tempSensor_ShutDownTest(void **state)
{
    int ret = TMP102_setShutdownMode(0);
    ret |= TMP102_setShutdownMode(1);
    assert_int_equal(ret, 0);
}

static void tempSensor_SetResolutionTest(void **state)
{
    int ret = TMP102_setResolution(0);
    ret |= TMP102_setResolution(1);
    ret |= TMP102_setResolution(2);
    ret |= TMP102_setResolution(3);
    assert_int_equal(ret, 0);
}

static void tempSensor_SetFaultBitTest(void **state)
{
    int ret = TMP102_setFaultbits(0);
    ret |= TMP102_setFaultbits(1);
    ret |= TMP102_setFaultbits(2);
    ret |= TMP102_setFaultbits(3);
    assert_int_equal(ret, 0);
}

static void tempSensor_SetEMTest(void **state)
{
    int ret = TMP102_setEM(0);
    ret |= TMP102_setEM(1);
    assert_int_equal(ret, 0);
}

static void tempSensor_SetCRTest(void **state)
{
    int ret = TMP102_setCR(0);
    ret |= TMP102_setCR(1);
    ret |= TMP102_setCR(2);
    ret |= TMP102_setCR(3);
    assert_int_equal(ret, 0);
}

static void tempSensor_getALTest(void **state)
{
    uint8_t bit;
    int ret = TMP102_readAL(&bit);
    assert_int_equal(ret, 0);
}

static void tempSensor_tempConversionTest(void **state)
{
    float temp_val;
    float ret1 = getTemperature(CELCIUS);
    float ret2 = getTemperature(FARENHEIT);
    float ret3 = getTemperature(KELVIN);
    ret2 = (ret2 - 32) *(5/9);
    ret3 = (ret3 - 273.149994);
    assert_true(ret1 == ret2);
}

int main()
{
    const struct CMUnitTest temptests[] = {	
	
    cmocka_unit_test(tempSensor_InitTest),
    cmocka_unit_test(tempSensor_GetTempTest),
    cmocka_unit_test(tempSensor_THighTest),
    cmocka_unit_test(tempSensor_TLowTest),
    cmocka_unit_test(tempSensor_WritePtrReg),
    cmocka_unit_test(tempSensor_ShutDownTest),
    cmocka_unit_test(tempSensor_SetResolutionTest),
    cmocka_unit_test(tempSensor_SetFaultBitTest),
    cmocka_unit_test(tempSensor_SetEMTest),
    cmocka_unit_test(tempSensor_SetCRTest),
    cmocka_unit_test(tempSensor_tempConversionTest),

	};

	return cmocka_run_group_tests(temptests, NULL, NULL);
    printf("testing......\n");
    return 0;

}

/**
 * @file test.c
 * @author Shreya Chakraborty
 * @brief Cmoka unit testing for light sensor register functions
 * @version 0.1
 * @date 2019-03-31
 * 
 * @copyright Copyright (c) 2019
 * 
 */
#include "myI2C.h"
#include "lightSensor.h"
#include <unistd.h>
#include "includes.h"
#include "cmocka.h"
#include "light.h"
#include "logger.h"

// i2c_struct_t i2c_handler;

static void lightSensor_InitTest(void **state)
{
    int ret = I2C_init(&i2c_handler);
    ret += APDS9301_powerup();
    assert_int_equal(ret, 0);
    //sleep(1);
}

static void lightSensor_GetLightTest(void **state)
{
    float lux;
    int ret = APDS9301_getlight(&lux);
    assert_int_equal(ret, 0);
}

static void lightSensor_GetCH0Test(void **state)
{
    uint16_t data;
    int ret = APDS9301_getCh0(&data);
    assert_int_equal(ret, 0);
}

static void lightSensor_GetCH1Test(void **state)
{
    uint16_t data;
    int ret = APDS9301_getCh1(&data);
    assert_int_equal(ret, 0);
}

static void lightSensor_GetIDregTest(void **state)
{
    uint8_t data;
    int ret = APDS9301_readIDreg(&data);
    assert_int_equal(ret, 0);
}

static void lightSensor_GetCTRLTest(void **state)
{
    uint8_t data;
    int ret = APDS9301_readCTRLreg(&data);
    assert_int_equal(ret, 0);
}

static void lightSensor_setgainTest(void **state)
{
    int ret = APDS9301_setTiming_gain(0);
    ret |= APDS9301_setTiming_gain(1);
    assert_int_equal(ret, 0);
}

static void lightSensor_setTimingTest(void **state)
{
    int ret = APDS9301_setTiming_integ(0);
    ret |= APDS9301_setTiming_gain(1);
    assert_int_equal(ret, 0);
}

static void lightSensor_interruptCTRLTest(void **state)
{
    int ret = APDS9301_interruptCTRLreg(0);
    ret |= APDS9301_interruptCTRLreg(1);
    assert_int_equal(ret, 0);
}

static void lightSensor_setTHlowlowTest(void **state)
{
    int ret = APDS9301_writeTHRESH_lowlow(1);
    assert_int_equal(ret, 0);
}

static void lightSensor_setTHhilowLTest(void **state)
{
    int ret = APDS9301_writeTHRESH_highlow(1);
    assert_int_equal(ret, 0);
}

static void lightSensor_getTHlowlowTest(void **state)
{
    uint8_t th_lowlow;
    int ret = APDS9301_readTHRESH_lowlow(&th_lowlow);
    assert_int_equal(ret, 0);
}

static void lightSensor_getTHlowhiTest(void **state)
{
    uint8_t th_lowhi;
    int ret = APDS9301_readTHRESH_lowhigh(&th_lowhi);
    assert_int_equal(ret, 0);
}

static void lightSensor_getTHhighlowTest(void **state)
{
    uint8_t th_hilow;
    int ret = APDS9301_readTHRESH_highlow(&th_hilow);
    assert_int_equal(ret, 0);
}

static void lightSensor_getTHhihiTest(void **state)
{
    uint8_t th_hihi;
    int ret = APDS9301_readTHRESH_lowlow(&th_hihi);
    assert_int_equal(ret, 0);
}

int main()
{
    const struct CMUnitTest temptests[] = {	
	
    cmocka_unit_test(lightSensor_InitTest),
    cmocka_unit_test(lightSensor_GetLightTest),
    cmocka_unit_test(lightSensor_GetCH0Test),
    cmocka_unit_test(lightSensor_GetCH1Test),
    cmocka_unit_test(lightSensor_GetIDregTest),
    cmocka_unit_test(lightSensor_GetCTRLTest),
    cmocka_unit_test(lightSensor_setgainTest),
    cmocka_unit_test(lightSensor_setTimingTest),
    cmocka_unit_test(lightSensor_interruptCTRLTest),
    cmocka_unit_test(lightSensor_setTHlowlowTest),
    cmocka_unit_test(lightSensor_setTHhilowLTest),
    cmocka_unit_test(lightSensor_getTHlowlowTest),
    cmocka_unit_test(lightSensor_getTHlowhiTest),
    cmocka_unit_test(lightSensor_getTHhighlowTest),
    cmocka_unit_test(lightSensor_getTHhihiTest),

	};

	return cmocka_run_group_tests(temptests, NULL, NULL);
    printf("testing......\n");
    return 0;

}